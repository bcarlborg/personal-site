<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/global-styles.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-woo-guy-32-32.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-woo-guy-96-96.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="180x180"
      href="/assets/favicon-woo-guy-180-180.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="og:title" content="Parsers (and Encoders) Everywhere" />
    <meta
      name="og:description"
      content="The personal website of Beau Carlborg" />
    <title>Taxonomy of Push Down Automata</title>
  </head>

  <body>
    <header>
      <a href="/index.html">⏎ back home</a>
    </header>
    <main>
      <article>
        <h1>⚠️Work in progress⚠️</h1>
        <p>
          I am currently in the process of writing this article. What you see
          here is merely a draft. If you stumbled across this article somehow,
          no worries, I have nothing to hide here. But know that what you see
          here is incomplete and is subject to frequent and dramatic changes in
          a way that a published article would not be.
        </p>
        <h1>Taxonomy of Push Down Automata</h1>
        <i>
          Originally Authored: July 2023 | Last Updated: July 2023 | Reading
          time: ~30 min | Author: Beau Carlborg
        </i>
        <p>
          Article contents:
          <br />
          <a href="section-1">1: Push Down Automata</a>
          <br />
          <a href="section-2">2: Components of a PDA Definition</a>
          <br />
          <a href="section-3">3: PDA Variant: The Base PDA</a>
          <br />
          <a href="section-4">
            4: PDA Variants: Multi & Optional Char Popping PDAs
          </a>
          <br />
          <a href="section-5">5: Empty Stack Acceptance PDAs</a>
          <br />
          <a href="section-6">6: Closing thoughts and additional remarks</a>
          <br />
          <a href="section_7">
            Appendix: Symbols and Notation used in this Document
          </a>
        </p>

        <div>
          <h2 id="section_1">1: Push Down Automata and their Variants</h2>
          <p>
            Push down automata (PDAs for short) are a specific model of
            automata.
          </p>

          <p>
            Automata are abstract models of computers. They are theoretical
            machines, defined using mathematical concepts, which allow us to
            model computation. An automata can model a program in a manner
            similar to how calculus and physics can model the movement of a ball
            tossed through the air. In the same way that studying physics with
            calculus can help us understand the physical world, studying
            automata can help us understand our programs and software.
          </p>

          <p>
            Automata can take many forms, but often in the context of computer
            science we discuss string recognizing automata. These can be
            imagined as machines that process a sequence of characters. Once all
            of the characters are processed, the automata either accepts or
            denies the string. This simple form of machine proves to be a
            surprisingly useful abstraction for most software.
          </p>

          <p>
            There are many different forms of string recognizing automata, each
            with varying capabilities and power. Often, teh key distinction
            between different forms of automata is the memory that the automata
            can utilize. The simplest automata like finite state machines may
            have only one memory cell whose value is determined by following a
            graph structure of states based on the input characters read by the
            automata. Other more powerful automata like turing machines have an
            infinitely large memory that can be filled with any number of
            predefined symbols. Each of these forms of automata is capable of
            modeling some class of computational problems.
          </p>

          <p>
            Push down automata are a form of automata that sits somewhere in the
            middle of the total hierarchy of automata forms. A PDA has one
            memory cell controlled with a finite state control graph (like the
            finite automata) as well as an infinite memory store structured as a
            stack., where elements can only be read from or written to the top
            of the stack. Their infinite memory gives them more power than the
            simpler automata like a finite automata, but the restricted form of
            the stack memory makes them less capable than an automata like a
            turing machine.
          </p>

          <p>Push Down automata may seem...</p>
        </div>

        <div>
          <h2 id="section_2">2: Introducing PDA variants</h2>

          <p>
            It is worth re-emphasizing that PDAs are only a theoretical model of
            computation, as such, it is entirely up to us to define what they
            are and how they work using tools from mathematics. In papers and
            books that cover push down automata, you will come across many
            slightly different definitions for PDAas yielding slight different
            PDA variants. The variants described are only slightly different
            manifestations of the same core abstract concept of a push down
            automata.
          </p>

          <p>
            Let's take sometime to reflect on what this core push down automata
            is and then we can extract a sort of framework that outlines teh
            information we need to include in a PDA definition.
          </p>

          <p>
            A PDA is an abstract machine that reads symbols from an input tape.
            Every time this machine reads a symbol, it may update an internal
            Finite Control state, or write and read symbols to and from an
            internal stack. After the string is read, the automata may accept
            the input string if certain conditions are met. In order to make a
            formal mathematical definition from this description, there are 4
            types of information we need to extract and make concrete.
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              Our input tape and our stack are both collection of symbols, we
              must specify all of the characters that our automata is equipped
              to process. There are an infinite number of symbols that could
              hypothetically be fed to an automata, but our PDA must specify the
              finite collection of symbols it is capable of reading from inout
              and pushing and popping from its stack. Usually this is done by
              including two finite sets in our definition. One set of input
              symbols and one set of stack symbols.
            </li>
            <li>
              <strong>Programming:</strong>
              As our automata executes, it will read input characters, it will
              update finite state, and it will push and pop symbols on our
              stack. Usually, this "programming" is encoded into a transition
              function. The transition function specifies what our automata will
              do at each step. Its inputs are the current state, some
              information about the current stack, and some information about
              the current input. The transition function maps that current
              configuration to a new configuration for the automata. The
              "program execution" of the automata is a matter of following the
              transition function from one configuration to another.
            </li>
            <li>
              <strong>Initial Configuration:</strong>
              Often times, we need to specify some information about the
              automata's configuration before it begins running. This starting
              configuration is necessary to ensure that our automata is prepped
              to run. Usually this involves specifying a starting state and some
              starting data for the PDA's stack.
            </li>
            <li>
              <strong>Accepting Conditions:</strong>
              Finally, we need to specficy the conditions with indicate our PDA
              has accepted a string. These conditions will be based on some
              aspect of the push down automata's internal configuration, wether
              that be it's finite state control or its stack, or its position in
              reading the input string.
            </li>
          </ol>

          <p>
            We can now use this framework to introduce a handful of PDA
            variants. We will show how each variant fits into this little
            framework and use the framework to highligh differences in the
            variants.
          </p>
        </div>

        <div>
          <h2 id="section_3">PDA variant 1: the base PDA</h2>

          <p>
            The first PDA variant we will introduce is one which has a very
            simple transition mechanism. This PDA always pops a single character
            off the top of its stack on every transition. This behavior creates
            a PDA with a very regular and consistent behavior. However,
            achieving this consistency on every transition does require a few
            awkward additions in the rest of our PDA definition.
          </p>

          <p>
            The first awkward aspect of this PDA is the discrepancy between the
            pushing and popping. In order for this base PDA to function
            properly, we must have the ability to push zero or many characters
            back onto the stack at every transition. This additional capability
            in the pushing step is necessary so that we can fully utilize our
            stack. Every PDA must be able to change the size of its stack during
            execution, wether by adding new characters and increasing its size,
            or removing characters and decreasing its size. Because our PDA pops
            one character on every transition, in order to grow the stack, we
            must have the ability to push more than one character on every turn,
            and in order to shrink the stack we must have the ability to push no
            characters onto the stack.
          </p>

          <p>
            And so, when we wish to add a new character onto the stack, we must
            pop the current top character, then in the next step push on a two
            character string composed of the character we just popped followed
            by the new character we wish to add. On transitions in which we wish
            to keep the stack the same, we must pop the current top of the
            stack, then push the same character back onto the stack. This setup
            has always felt a bit awkward to me, but it is necessary.
          </p>

          <p>
            In order to support single character popping on every transition, we
            also need to make an addition to our PDAs initial configuration. We
            must add a starting stack character to our definition of a PDA.
            Every transition our PDA makes requires there already be one
            character to pop, and so, in order for our first transition to
            function, we must already have one character on the stack.
          </p>

          <p>
            Now, we can put together a complete PDA definition in the
            organization of the framework introduced above.
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              This PDA has two sets of character we are concerned with, the
              character set of the input and of the stack,
              <math display="inline">
                <mtext>Σ</mtext>
              </math>
              and
              <math display="inline">
                <mtext>Γ</mtext>
              </math>
              respectively. Each of these refers to a simple set of symbols.
            </li>

            <li>
              <strong>Programming:</strong>
              the programming of this PDA consists of its set of finite states
              as well as a transition function. Our set of finite states will be
              represented by the set
              <math display="inline">
                <mtext>Q</mtext>
              </math>
              and our transition function will be represented by the symbol
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              .
              <math display="inline">
                <mtext>Q</mtext>
              </math>
              is a Simple set of symbols, and
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              is a transition function of the form
              <math><mi>δ: Q x { Σ ∪ ɛ } x Γ → P(Q x Γ*)</mi></math>
              . This can be read as saying, the transition function
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              takes 3 inputs: a required current state, an optional current
              input character, and a required symbol at the top of the stack.
              The function's output is a set of state and stack symbol string
              pairs.
            </li>

            <li>
              <strong>Initial Configuration:</strong>
              Our definition must include two initial configuration values. Like
              any finite state machine, we must include a starting state
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
              </math>
              where
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
                <mtext>∊ Q</mtext>
              </math>
              . As mentioned above, for this particular push down automata
              variant, we also must include a starting stack symbol
              <math display="inline">
                <msub>
                  <mi>Z</mi>
                  <mn>0</mn>
                </msub>
              </math>
              where
              <math display="inline">
                <msub>
                  <mi>Z</mi>
                  <mn>0</mn>
                </msub>
                <mtext>∊ Γ</mtext>
              </math>
            </li>

            <li>
              <strong>Accepting Conditions:</strong>
              finally, we must specify the acceptance conditions for this PDA.
              Much like finite automata, this PDA uses a set of accepting state
              conditions
              <math display="inline">
                <mtext>F</mtext>
              </math>
              where
              <math display="inline">
                <mtext>F ⊆ Q</mtext>
              </math>
              . If the PDA is one of of these states when the full input has
              been read, then the PDA accepts the current string.
            </li>
          </ol>

          <p>
            We can put all of these values together into a 7 components tuple (a
            7-tuple).
          </p>

          <p>
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>

          <p>
            Any base PDA that we will to define will need to specify values for
            these 7 properties.
          </p>
        </div>

        <div>
          <h2 id="section_4">
            4: PDA Variants: Multi & Optional Char Popping PDAs
          </h2>

          <p>
            Another common form of PDA definition is one in which the PDA has
            the ability to pop zero or many characters on each transition step.
            This is a natural extension from the base PDA, and can make the
            programming of the PDA much simpler.
          </p>

          <p>
            In addition to adding a bit of flexibility to our PDA transition
            function, this construction also feels a bit more elegant than the
            single popping PDA. For one, this variant has a nice symmetry
            between the characters pushed and popped and does not require the
            awkward practice of pushing back the character you popped when you
            which to add a new character to the stack. Even better though, this
            variant removes the need for the start symbol on our stack. We added
            the start symbol to accommodate the requirement that every
            transition pops a character, but this variant has no such
            requirement, and so we can remove that from our definition
          </p>

          <p>
            Let's put down a definition for multi character popping PDAs using
            the same framework again.
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              Just like the previous PDA variant, this PDA has two character
              sets we care about, the input symbols and the stack symbols,
              <math display="inline">
                <mtext>Σ</mtext>
              </math>
              and
              <math display="inline">
                <mtext>Γ</mtext>
              </math>
              respectively.
            </li>

            <li>
              <strong>Programming:</strong>
              Just as before, this PDA will have a set of states,
              <math display="inline">
                <mtext>Q</mtext>
              </math>
              , for its finite state control. The transition function for this
              PDA will be similar to the last, but will include information that
              allows for popping multiple symbols on every transition. Again,
              this transition function will be represented by the symbol
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              . This transition can be formally defined as is a transition
              function of the form
              <math><mi>δ: Q x { Σ ∪ ɛ } x Γ* → P(Q x Γ*)</mi></math>
              . This can be read as saying, the transition function
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              takes 3 inputs: a required current state, an optional current
              input character, and a string of zero or many stack symbols from
              the top of the stack. The function's output is a set of state and
              stack symbol string pairs.
            </li>

            <li>
              <strong>Initial Configuration:</strong>
              This PDA variant will require a starting finite control state just
              as before. Again this start state will be
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
              </math>
              where
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
                <mtext>∊ Q</mtext>
              </math>
              . This PDA variant will not require a starting stack symbol as our
              first PDA variant did.
            </li>

            <li>
              <strong>Accepting Conditions:</strong>
              finally, we must specify the acceptance conditions for this PDA.
              These will be the same set of accepting states as were defined for
              the base PDA above.
              <math display="inline">
                <mtext>F</mtext>
              </math>
              where
              <math display="inline">
                <mtext>F ⊆ Q</mtext>
              </math>
              .
            </li>
          </ol>

          <p>
            We can put all of these values together into a 6 components tuple (a
            6-tuple).
          </p>
          <p>
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>
        </div>

        <div>
          <h2 id="section_5">5: Empty Stack Acceptance PDAs</h2>
          <p>
            The final PDA variant we will consider is one that is often
            introduced in the latter half of text book chapters on PDAs. Unlike
            the previous variants we have considered, which all make
            modifications on the transition function itself, this variant makes
            a modification to the acceptance conditions used by the PDA. Instead
            of using a set of final states in the finite control unit, this PDA
            accepts a string when the input is fully read, and the PDA's stack
            is empty.
          </p>

          <p>
            To apply this change to our definition, we only need to specify that
            an empty stack is an accepting condition. This is simple enough to
            express in an english sentence, but can be tricky to write out
            formally. Most books on the subject choose to simply specify the
            acceptance condition in a sentence.
          </p>

          <p>
            We could make either of the PDA's we've defined so far an empty
            stack acceptance PDA by simply removing the final states from their
            definition and specifying that they accept with empty stacks.
          </p>

          <p>
            So a single character popping PDA with empty stack acceptance would
            be defined with the 6-tuple:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>)</mi>
            </math>
            with a note specifying that it accepts when the stack is emptied.
          </p>

          <p>
            And a multi character popping PDA with empty stack acceptance would
            be defined with the 5-tuple:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>)</mi>
            </math>
            with a note specifying that it accepts when the stack is emptied.
          </p>
        </div>

        <div>
          <h2 id="section_6">6: Closing thoughts and additional remarks</h2>
        </div>

        <p><strong>Why choose one definition over the other?</strong></p>

        <p>
          Ultimately it comes down to your goals. Some variants are better for
          representing certain proofs, others are easier to program. It is not
          that different from choosing one programming language over the other.
          Usually, each language can achieve the same end results, but it comes
          down to how well suited that language is for the task.
        </p>

        <p><strong>Are these variants truly interchangeable?</strong></p>

        <p>
          Computationally, yes, these are interchangeable, in that each of the
          PDA variants can accept every language that another PDA variant would.
          In terms of complexity, the situation is a bit more complicated. Some
          of the machines can represent the an automata for the same language
          with different complexity properties. The multi popping PDA in
          particular is slightly better at hiding complexity than the others.
        </p>

        <p><strong>How could we prove they are equivalent?</strong></p>

        <p>
          The process of proving that two automata variants are equivalent comes
          down to showing that any language that can be accepted by an automata
          in the style of variant A can also be accepted by an automata in the
          style of variant B and vice versa.
        </p>

        <p>
          Most textbooks that cover push down automata give specific examples of
          this process and how it can work.
        </p>

        <div>
          <h2 id="section_7">
            Appendix: Symbols and Notation used in this Document
          </h2>
          <ul>
            <li>
              <math><mi>δ</mi></math>
              = lower case delta
            </li>
            <li>
              <math><mi>ɛ</mi></math>
              = lower case epsilon
            </li>
            <li>
              <math><mi>Σ</mi></math>
              = upper case sigma
            </li>
            <li>
              <math><mi>Γ</mi></math>
              = upper case gamma
            </li>

            <li>
              <math><mi>A x B</mi></math>
              = the set containing all possible pairs with one element from A
              and one from B -- known as the cartesian product of A and B
            </li>
            <li>
              <math><mi>P(A)</mi></math>
              = the set containing all subsets of A -- known as the power set of
              A
            </li>
          </ul>
        </div>
      </article>
    </main>
  </body>
</html>
