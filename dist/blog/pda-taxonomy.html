<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/global-styles.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-woo-guy-32-32.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-woo-guy-96-96.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="180x180"
      href="/assets/favicon-woo-guy-180-180.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="og:title" content="Parsers (and Encoders) Everywhere" />
    <meta
      name="og:description"
      content="The personal website of Beau Carlborg" />
    <title>Taxonomy of Push Down Automata</title>
  </head>

  <body>
    <header>
      <a href="/index.html">⏎ back home</a>
    </header>
    <main>
      <article>
        <h1>⚠️Work in progress⚠️</h1>
        <p>
          I am currently in the process of writing this article. What you see
          here is merely a draft. If you stumbled across this article somehow,
          no worries, I have nothing to hide here. But know that what you see
          here is incomplete and is subject to frequent and dramatic changes in
          a way that a published article would not be.
        </p>
        <h1>Taxonomy of Push Down Automata</h1>
        <i>
          Originally Authored: July 2023 | Last Updated: July 2023 | Reading
          time: ~30 min | Author: Beau Carlborg
        </i>
        <p>
          Article contents:
          <br />
          <a href="section-1">1: Push Down Automata and their Variants</a>
          <br />
          <a href="section-2">2: Components of a PDA Definition</a>
          <br />
          <a href="section-3">3: Single Character Popping PDAs</a>
          <br />
          <a href="section-4">4: Multi-Character Popping PDAs</a>
          <br />
          <a href="section-5">5: Empty Stack Accepting PDAs</a>
          <br />
          <a href="section-6">6: Closing Thoughts and Additional Remarks</a>
          <br />
          <a href="section_7">
            Appendix: Symbols and Notation used in this Document
          </a>
        </p>

        <div>
          <h2 id="section_1">1: Push Down Automata and their Variants</h2>
          <p>
            Push down automata (PDAs for short) are a specific model of
            automata.
          </p>

          <p>
            Automata are abstract models of computers. They are theoretical
            machines, defined using mathematical concepts in the sam way that
            calculus can help us model a ball's path through the air, automata
            can help us model programs. Studying automata can help us
            conceptualize the programs and algorithms we work with on a regular
            basis.
          </p>

          <p>
            Automata can take many forms, but in computer science we often
            discuss string recognizing automata. A specific automaton can be
            imagined as a machine that processes a sequence of characters. Once
            all of the characters are processed, the automaton either accepts or
            denies the string. This simple form of machine proves to be a
            surprisingly useful abstraction for most software.
          </p>

          <p>
            There are many different forms of string recognizing automata, each
            with varying capabilities and power. Often, the key distinction
            between different forms of automata is the memory that the automata
            can utilize. The simplest automata like finite state machines may
            have only one memory cell whose value is determined by following a
            graph structure of states based on the input characters read by the
            automata. Other more powerful automata like turing machines have an
            infinitely large memory that can be filled with any number of
            predefined symbols. Push down automata are one type of automata that
            sits somewhere in the middle of the total hierarchy of automata.
          </p>

          <p>
            A PDA has one memory cell controlled with a finite state control
            graph as well as an infinite memory store structured as a stack.,
            where elements can only be read from or written to the top of the
            stack. Their infinite memory gives them more power than the simpler
            automata like a finite automata, but the restricted form of the
            stack memory makes them less capable than an automata like a turing
            machine.
          </p>

          <p>
            PDAs are appropriate models fora surprising number of practical
            computational task. PDA's model programs that straddle the line
            dividing easy and hard problems. A program that can be modeled by a
            PDA can often be solved quite efficiently, but a problem to
            difficult to be solved with a push down automata may be difficult to
            solve in a reasonable time frame. Many computational problems of
            practical importance like parsing a programming language or a depth
            first search of a tree can be modeled with a push down automata.
          </p>

          <p>
            PDAs are often given at least a chapter's worth of focus in books
            covering theoretical computer science. A typical coverage of PDAs
            will introduce a definition of a nondeterministic push down
            automata, give a few example PDAs, provide a proof of equivalence
            with context free grammars, and maybe introduce deterministic push
            down automata.
          </p>

          <p>
            I have struggled with the coverage of push down automata in a number
            of resources because I failed to fully grasp the initial definition
            that the content build on. I have two theories about why these
            definitions were difficult to wrap my head around.
          </p>

          <p>
            Firstly, there are a handful of different PDA definition in use
            across different books on the subject. While all of these
            definitions are quite similar adn define variants that are
            computationally equivalent, the variety can be disorienting. The
            definitions all yield slightly different push down automata variants
            with their own subtleties. It took me longer than I would like to
            admit, to realize that these different variants were in use. It took
            me even longer to internalize teh difference in the definitions and
            feel comfortable switching between them.
          </p>

          <p>
            Secondly, I feel that push down automata are simply peculiar. PDAs
            have neither the austere simplicity of a finite state machine, nor
            the all encompassing flexibility of a turing machine. Instead, they
            are an automata with a somewhat awkward stack memory structure whose
            restrictions can be tricky to capture using a mathematical
            definition. Defining PDAs often involves additions to our
            definitions like stack based symbols that just seem awkward.
          </p>

          <p>
            It is because of my trouble with these definitions that I wanted to
            write this post. Overtime, I was able to develop my own mental model
            for organizing and thinking about these definitions that helped me
            build a conceptual foundation for PDAs and begin to understand the
            more interesting results about this automata.
          </p>
        </div>

        <div>
          <h2 id="section_2">2: Components of a PDA Definition</h2>

          <p>
            It is worth re-emphasizing that PDAs are only a theoretical model of
            computation, as such, it is entirely up to us to define what they
            are and how they work using tools from mathematics. The most common
            definitions of push down automata use sets of symbols and functions
            over those sets as the building blocks of a PDA definition.
          </p>

          <p>
            A typical automata definition may look something like this:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
            . This definition is a collection of 7 symbols that each represent
            some set, function, or symbol. Taken together, the symbols are a
            7-tuple that specifies a particular push down automata.
          </p>

          <p>
            At first encounter, it may not even seem possible that a series of
            symbols representing sets and functions can define an abstract
            computer. It is not a particularly intuitive representation.
          </p>

          <p>
            To understand a definition like this, I find it productive to think
            about the broad types of information that need to be formalized,
            then figure out how the symbols fit into those categories.
          </p>

          <p>
            Our automata is akin to a program on a computer in more than just an
            abstract sense. I find that using a similar mental model for
            specifying programs is useful for specifying and automata.
          </p>

          <p>
            When we consider a program, we need to know about the program's:
          </p>

          <ul>
            <li>
              <strong>Program Character Sets:</strong>
              What symbols are used to represent the program and how are they
              encoded. Is the program a sequence of unicode characters? or a
              binary blob composed of 16 bit machine code instructions.
            </li>

            <li>
              <strong>Program Static Data or Initial Configurations:</strong>
              Programs are not just code, the programs include static data that
              the program references. Information like the default values for
              variables and constants all need to be specified in the program
              data itself.
            </li>

            <li>
              <strong>Program Code:</strong>
              The actual instruction that the program executes. These
              instructions define the program's behavior and control flow.
            </li>

            <li>
              <strong>Program Accepting or Terminating Conditions:</strong>
              When is the program done, and how do we interpret its results,
              does the program write a certain value to the stdout, does it set
              some register to indicate it was successful? We need a way to
              interpret the output of our program and determine wether it was
              successful or unsuccessful.
            </li>
          </ul>

          <p>
            We can apply this same mental model of a program's content to the
            definition of a push down automata. The information in our PDA
            definition or specification needs to explain:
          </p>

          <ol>
            <li>
              <strong>Automata Character Sets:</strong>
              As mentioned before, a PDA processes an input string, and writes
              and reads data from an internal stack. Our input tape and our
              stack are both collection of symbols, we must specify all of the
              characters that our automata is equipped to process.
            </li>

            <li>
              <strong>Automata Programming:</strong>
              As our automata executes, it will read input characters, it will
              update finite state, and it will push and pop symbols on our
              stack. This behavior can be encoded using a function that
              describes how the automata updates its internal state as new
              characters are processed.
            </li>

            <li>
              <strong>Automata Initial Configuration:</strong>
              Just like a program, our PDA also may have some initial
              configuration or default values. PDA's specify an initial control
              state and may have some initial data on their stack in order to
              kick off their execution properly.
            </li>

            <li>
              <strong>Automata Accepting Conditions:</strong>
              Finally, we need to specify the conditions with indicate our PDA
              has accepted a string. These conditions will be based on some
              aspect of the push down automata's internal data (finite control
              and the stack).
            </li>
          </ol>

          <p>
            Every symbol in our definition helps helps to specify one of the
            above aspects of our program. Understanding the formal definitions
            of push down automata is a matter of internalizing how each symbol
            and its value informs one of the above qualities in our definition.
          </p>

          <p>
            To make things more concrete, we will explain a few common PDA
            definition variants and show how each fits into this little
            framework.
          </p>
        </div>

        <div>
          <h2 id="section_3">3: Single Character Popping PDAs</h2>

          <p>
            The first PDA variant we will discuss is one that pops a single
            character off the stack on every transition. This is a common PDA
            variant introduced in CS theory and is often the base that other PDA
            variants are based off of. We will build up a definition for this
            PDA using the framework above.
          </p>

          <p>
            We first begin with the simplest category, character sets. We need
            to introduce two sets of symbols this PDA can process. One set for
            the input string, and another for the stack.
          </p>

          <p>
            <strong>Character sets:</strong>
            Our PDA uses two character sets,
            <math display="inline">
              <mtext>Σ</mtext>
            </math>
            and
            <math display="inline">
              <mtext>Γ</mtext>
            </math>
            , these refer to the set of input symbols the automata is capable of
            working with.
            <math display="inline">
              <mtext>Σ</mtext>
            </math>
            is the set of symbols the automata can read in the input strings and
            <math display="inline">
              <mtext>Γ</mtext>
            </math>
            is the set of symbols that the automata can read and write from its
            stack.
          </p>

          <p>
            Now that we have established the symbols this PDA will use, we can
            formalize the single popping behavior of this push down automata.
            This quality will be captured by the programming in our framework
            above. As with any PDA's programming we need to define a finite set
            of control states for the automata and a transition function which
            outlines how the automata moves from one state to another as a
            result of the current input and stack character. The states will be
            a simple set and the transition function will read an input
            character, read a finite control state, and pop a character off of
            the top of the stack, then output possible next states and new data
            to add to the stack.
          </p>

          <p>
            <strong>Programming:</strong>
            Our set of finite states will be represented by the symbol
            <math display="inline">
              <mtext>Q</mtext>
            </math>
            and our transition function will be represented by the symbol
            <math display="inline">
              <mtext>δ</mtext>
            </math>
            .
            <math display="inline">
              <mtext>Q</mtext>
            </math>
            is a Simple set of symbols, and
            <math display="inline">
              <mtext>δ</mtext>
            </math>
            is a transition function of the form
            <math><mi>δ: Q x { Σ ∪ ɛ } x Γ → P(Q x Γ*)</mi></math>
            . This can be read as saying, the transition function
            <math display="inline">
              <mtext>δ</mtext>
            </math>
            takes 3 inputs: a required current state, an optional current input
            character, and a required symbol at the top of the stack. The
            function's output is a set of state and stack symbol string pairs.
          </p>

          <p>
            There is a peculiar aspect to this transition function worth
            highlighting. on every transition we must pop one character from the
            stack, but we may push zero or many character back on. To me this
            seemed an unsightly asymmetry at first, however, it is necessary in
            order to grow and reduce the stack. When we wish to reduce the stack
            size, we may pop a character and push an empty string. When we wish
            to grow the stack, we may pop a character, then push a string with
            that same character and additional new stack characters appended on.
          </p>

          <p>
            With the programming and character sets established, we can now
            consider the PDA's initial configuration. In order to support single
            character popping on every transition we must add a starting stack
            character to our initial configuration. Every transition our PDA
            makes requires there already be one character to pop, and so, in
            order for our first transition to function, we must already have one
            character on the stack.
          </p>

          <p>
            <strong>Initial Configuration:</strong>
            Our initial configuration must include two values. Like any finite
            state machine, we must include a starting state
            <math display="inline">
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
            </math>
            where
            <math display="inline">
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mtext>∊ Q</mtext>
            </math>
            . As mentioned above, for this particular push down automata
            variant, we also must include a starting stack symbol
            <math display="inline">
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
            </math>
            where
            <math display="inline">
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mtext>∊ Γ</mtext>
            </math>
          </p>

          <p>
            Finally, we must specify the acceptance conditions for this PDA.
            Much like finite automata, this PDA uses a set of accepting state
            which are a subset of the states introduced in the programming of
            this automata.
          </p>

          <p>
            <strong>Accepting Conditions:</strong>
            finally, we must specify the acceptance conditions for this PDA.
            Much like finite automata, this PDA uses a set of accepting state
            conditions
            <math display="inline">
              <mtext>F</mtext>
            </math>
            where
            <math display="inline">
              <mtext>F ⊆ Q</mtext>
            </math>
            . If the PDA is one of of these states when the full input has been
            read, then the PDA accepts the current string.
          </p>

          <p>
            We can put all of these values together into a 7 components tuple (a
            7-tuple). Any base PDA that we will to define will need to specify
            values for these 7 properties.
          </p>

          <p>
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>

          <p>
            By thinking about this automata definition using a mental framework
            in which automata are like programs and must specify character sets,
            initial configurations, programming, and acceptance conditions, it
            becomes much easier to breakdown a definition like this. Instead of
            seeing an arbitrary list of symbols, we can see that each symbols
            helps build out a core aspect of our automata's behavior.
          </p>
        </div>

        <div>
          <h2 id="section_4">4: Multi-Character Popping PDAs</h2>

          <p>
            Another common form of PDA definition is one in which the PDA has
            the ability to pop zero or many characters on each transition step.
            This is a natural extension from the base PDA, and can make the
            programming of the PDA much simpler. This variant's definition is
            nearly identical to the base single character popping PDA's but with
            two slight modifications, one in the programming, and another in the
            initial configuration.
          </p>

          <p>
            With regard to programming, this PDA will use the sam set of finite
            control states, but will need a slightly updated transition function
            to support popping multiple characters. This is a relatively easy
            update and merely requires updating the typing of our transition
            function. We simply need to accept
            <math display="inline">
              <mi>Γ*</mi>
            </math>
            as an input rather than
            <math display="inline">
              <mi>Γ</mi>
            </math>
            .
          </p>

          <p>
            <strong>Programming:</strong>
            Our PDA will have a set of states,
            <math display="inline">
              <mtext>Q</mtext>
            </math>
            , for its finite state control. The transition function for this PDA
            will be represented by the symbol
            <math display="inline">
              <mtext>δ</mtext>
            </math>
            which is a function with the form,
            <math><mi>δ: Q x { Σ ∪ ɛ } x Γ* → P(Q x Γ*)</mi></math>
            . This can be read as saying, the transition function
            <math display="inline">
              <mtext>δ</mtext>
            </math>
            takes 3 inputs: a required current state, an optional current input
            character, and a string of zero or many stack symbols from the top
            of the stack. The function's output is a set of state and stack
            symbol string pairs.
          </p>

          <p>
            The other difference in the multi popping PDA's definition is in the
            initial configuration this PDA needs. In the base PDA we needed to
            add a start symbol to our stack so that our transition function
            could make a valid first move. But with this PDA, that is no longer
            necessary. We can have transitions which pop no characters from our
            stack, and so, starting with an empty stack is ok. with this, our
            new initial configuration is simplified:
          </p>

          <p>
            <strong>Initial Configuration:</strong>
            This PDA variant will require a starting finite control state
            represented by the symbol
            <math display="inline">
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
            </math>
            where
            <math display="inline">
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mtext>∊ Q</mtext>
            </math>
            . This PDA variant will not require a starting stack symbol as our
            first PDA variant did.
          </p>

          We can put this updated programming and initial state together with
          teh unchanged character sets and accepting conditions from the
          previous automata definition and form the following definition:

          <p>
            Our multi-character popping PDA is defined by the following 6-tuple
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>

          <p>
            The Difference between this and the base PDA definition are small --
            a slight change to our transition function and teh removal of a
            state symbol -- but by using a mental model where PDAs are built
            from character sets, initial state, programming and accepting
            states, the significance of the differences are more easily
            understood.
          </p>
        </div>

        <div>
          <h2 id="section_5">5: Empty Stack Accepting PDAs</h2>
          <p>
            The final PDA variant we will consider is one that is often
            introduced in the latter half of text book chapters on PDAs. Unlike
            the previous variants we have considered, which all make
            modifications on the transition function itself, this variant makes
            a modification to the acceptance conditions used by the PDA. Instead
            of using a set of final states in the finite control unit, this PDA
            accepts a string when the input is fully read, and the PDA's stack
            is empty.
          </p>

          <p>
            To apply this change to our definition, we only need to specify that
            an empty stack is an accepting condition. This is simple enough to
            express in an english sentence, but can be tricky to write out
            formally. Most books on the subject choose to simply specify the
            acceptance condition in a sentence.
          </p>

          <p>
            We could make either of the PDA's we've defined so far an empty
            stack acceptance PDA by simply removing the final states from their
            definition and specifying that they accept with empty stacks.
          </p>

          <p>
            So a single character popping PDA with empty stack acceptance would
            be defined with the 6-tuple:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>)</mi>
            </math>
            with a note specifying that it accepts when the stack is emptied.
          </p>

          <p>
            And a multi character popping PDA with empty stack acceptance would
            be defined with the 5-tuple:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>)</mi>
            </math>
            with a note specifying that it accepts when the stack is emptied.
          </p>
        </div>

        <div>
          <h2 id="section_6">6: Closing Thoughts and Additional Remarks</h2>
        </div>

        <p><strong>Why choose one definition over the other?</strong></p>

        <p>
          Ultimately it comes down to your goals. Some variants are better for
          representing certain proofs, others are easier to program. It is not
          that different from choosing one programming language over the other.
          Usually, each language can achieve the same end results, but it comes
          down to how well suited that language is for the task.
        </p>

        <p><strong>Are these variants truly interchangeable?</strong></p>

        <p>
          Computationally, yes, these are interchangeable, in that each of the
          PDA variants can accept every language that another PDA variant would.
          In terms of complexity, the situation is a bit more complicated. Some
          of the machines can represent the an automata for the same language
          with different complexity properties. The multi popping PDA in
          particular is slightly better at hiding complexity than the others.
        </p>

        <p><strong>How could we prove they are equivalent?</strong></p>

        <p>
          The process of proving that two automata variants are equivalent comes
          down to showing that any language that can be accepted by an automata
          in the style of variant A can also be accepted by an automata in the
          style of variant B and vice versa.
        </p>

        <p>
          Most textbooks that cover push down automata give specific examples of
          this process and how it can work.
        </p>

        <p>
          <strong>
            Which books have you been referencing to learn about PDAs:
          </strong>
        </p>
        <p>
          Many... but these are a few i like with a note about their style and
          quality:
        </p>
        <ol>
          <li>book 1: notes about style</li>
          <li>book 2: notes about style</li>
          <li>book 2: notes about style</li>
        </ol>

        <div>
          <h2 id="section_7">
            Appendix: Symbols and Notation used in this Document
          </h2>
          <ul>
            <li>
              <math><mi>δ</mi></math>
              = lower case delta
            </li>
            <li>
              <math><mi>ɛ</mi></math>
              = lower case epsilon
            </li>
            <li>
              <math><mi>Σ</mi></math>
              = upper case sigma
            </li>
            <li>
              <math><mi>Γ</mi></math>
              = upper case gamma
            </li>

            <li>
              <math><mi>A x B</mi></math>
              = the set containing all possible pairs with one element from A
              and one from B -- known as the cartesian product of A and B
            </li>
            <li>
              <math><mi>P(A)</mi></math>
              = the set containing all subsets of A -- known as the power set of
              A
            </li>
          </ul>
        </div>
      </article>
    </main>
  </body>
</html>
