<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/global-styles.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-woo-guy-32-32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-woo-guy-96-96.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="180x180"
      href="/assets/favicon-woo-guy-180-180.png"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="og:title" content="Parsers (and Encoders) Everywhere" />
    <meta
      name="og:description"
      content="The personal website of Beau Carlborg"
    />
    <title>Taxonomy of Push Down Automata</title>
  </head>

  <body>
    <header>
      <a href="/index.html">⏎ back home</a>
    </header>
    <main>
      <article>
        <h1>⚠Work in progress article⚠</h1>
        <p>
          I am currently in the process of writing this article. What you see
          here is merely a draft. If you stumbled across this article somehow,
          no worries, I have nothing to hide here. But know that what you see
          here is incomplete and is subject to frequent and dramatic changes in
          a way that a published article would not be.
        </p>
        <h1>Taxonomy of Push Down Automata</h1>
        <i>
          Originally Authored: July 2023 | Last Updated: July 2023 | Reading
          time: ~30 min | Author: Beau Carlborg
        </i>
        <p>
          Article contents:
          <br />
          <a href="section-1"> 1: PDAs: a very particular kind of automaton</a>
          <br />
          <a href="section-2">2: Building up PDA variants</a>
          <br />
          <a href="section-3">4: Overview of PDA variants</a>
          <br />
          <a href="section-4">4: Proving two PDA variants are equivalent</a>
          <br />
          <a href="section-5">5: PDA variant equivalence examples</a>
          <br />
          <a href="section-6">6: Closing thoughts and additional remarks</a>
        </p>

        <hr />

        <div>
          Symbols used in this document
          <ul>
            <li>
              <math><mi>δ</mi></math> = lower case delta
            </li>
            <li>
              <math><mi>ɛ</mi></math> = lower case epsilon
            </li>
            <li>
              <math><mi>Σ</mi></math> = upper case sigma
            </li>
            <li>
              <math><mi>Γ</mi></math> = upper case gamma
            </li>
          </ul>
        </div>

        <p>Mathematical notation used in this document</p>

        <ul>
          <li>
            <math><mi>A x B</mi></math> = the set containing all possible pairs
            with one element from A and one from B -- known as the cartesian
            product of A and B
          </li>
          <li>
            <math><mi>P(A)</mi></math> = the set containing all subsets of A --
            known as the power set of A
          </li>
        </ul>

        <hr />

        <div>
          <h2 id="section_1">1: PDAs: a very particular kind of automaton</h2>
          <p>
            There is a certain trickiness to push down automata. Most books
            about the theory of computation, compilers, or theoretical computer
            science cover them in some depth, but I've always had a hard time
            following.
          </p>

          <p>
            Compared to finite automata and turing machines, push down automata
            (PDAs) have always seemed a bit quirky to me. The other common
            automata have definitions that seem well rounded and intuitive,
            while PDAs always seems to have odd little quirks.
          </p>

          <p>
            With time, I realized that PDA's quirky and puzzling nature stems
            from the fact that most books and resources with coverage of PDAs
            use use slightly different definitions for this particular type of
            automata.
          </p>

          <p>
            Most of these differences are small enough. A difference in the
            number of characters each step can pop, a difference in the the way
            that strings are accepted. These differences are easy to miss. When
            skimming a new book on the subject, you might not even notice, but
            they are there.
          </p>

          <p>
            Until you begin going into resources on the topic with a certain
            defensiveness, looking for the differences. You will find your self
            confused.
          </p>

          <p>
            I felt like all of these little differences (can I find a new word
            for difference?) were holding me back from building and intuition
            about PDAs. So I decided to sit down, wrangle in all the variants,
            and create my own taxonomy of PDAs.
          </p>
        </div>

        <div>
          <h2 id="section_2">2: Introducing PDA variants</h2>

          <p>
            I believe that the best way to introduce the different PDA variants
            is to first define a base PDA variant. Then, we can construct our
            other PDA variants by making slight modifications to that base
            construction.
          </p>

          <h3>PDA variant 1: the base PDA</h3>
          <p>
            I define a base PDA such that its definition is a minimal extension
            of a finite automata. After all, a push down automata is really
            nothing more than a finite automata with an additional stack of
            data. A PDA can push symbols to that stack and read symbols from
            that stack to determine its next move.
          </p>

          <p>
            TODO: maybe add in finite automata definition here for comparison
          </p>

          <p>
            If we build from the definition of a finite automata, what details
            do we need to specify in order add a stack, and thus create a PDA.
          </p>

          <p>
            To begin with, we will need to define what will go on the stack. Our
            definition of a base PDA will need to specify symbols that can be
            written to, and thus read from, the stack. It might be possible to
            get away with always simply reusing the input tape symbols, but
            defining them separately gives us more flexibility (footnote: I am
            not even sure if the PDA would be powerful enough if we only used
            the input symbols).
          </p>

          <p>
            We will use the character <math><mi>Γ</mi></math> to refer to this
            set of stack symbols in our definition.
          </p>

          <p>
            We also need a way to specify how data is written to and read from
            the stack in our definition. We can do this by including stack
            symbols in the input and output of our transition function. the
            stack symbol in the input of the function will be recognized just
            like a symbol from the input is, and a stack symbol in the output
            will be written to the stack at the end of a transition. In order to
            do this, we will need to update the type of our function
            <math><mi>δ</mi></math> .
          </p>

          <p>
            Our finite automata transition function had the following type (TODO
            insert). Our push down automata transition function will be
            specified as
            <math><mi>δ: Q x Σ x Γ → P(Q x Γ*)</mi></math> (TODO include
            epsilons)
          </p>

          <p>
            This new transition function can be read as,
            <math><mi>δ</mi></math> is a function that takes, a state, an input
            symbol, and a stack symbol as input, and outputs many pairs of a
            state and a string stack symbols.
          </p>

          <p>
            Another way of interpreting the transition function
            <math><mi>δ</mi></math> is that it specifies how on every single
            move, a character from input and from the stack are read, and
            depending on those values, a string is pushed onto the top of the
            stack.
          </p>

          <p>
            In the interest of keeping our push down automata "simple," I've
            chosen to specify it such that on transition, a character is popped
            from the stack, and multiple characters can be pushed onto the
            stack. This gives the base PDA a very consistent execution in which
            every transition is uniform to a certain degree.
          </p>

          <p>However, this transition function has two quirky aspects.</p>

          <p>
            First, on every step, the PDA can only pop one character, but it can
            push many characters or no characters. Why have that discrepancy? It
            is a concession we must make for the simplicity of always popping
            one character in a transition. Take a moment to consider -- when we
            always pop a character, we need to be able push 0 characters on a
            turn or push many characters on a turn in order to shrink and grow
            the stack respectively.
          </p>

          <p>
            Second, because our transition function requires that every step pop
            a symbol from the stack, our PDA cannot start with an empty stack.
            If our program had an empty stack to begin with, then, by
            definition, there would be no viable first transition to get things
            going. We can get around think kink by introducing another field to
            our definition: a stack start symbol (todo choose character). By
            specifying a default first character, we can ensure that we have a
            toe hold into running our first transition.
          </p>

          [TODO PICK UP HERE -- tie it all together into a definition] [TODO,
          update the headers]

          <p>
            TODO: can we get fewer line breaks in here somehow? maybe by bolding
            a few characters or something
          </p>

          <h3>PDA variant 2: the null character popping PDA</h3>
          <h3>PDA variant 3: the multi character popping PDA</h3>
          <h3>PDA variant 4: the empty stack accepting PDA</h3>
          [TODO, make a new section for the matrix of the push down automata
          variants]
        </div>
        <div>
          <h2 id="section_3">3: Proving two PDA variants are equivalent</h2>
        </div>

        <div>
          <h2 id="section_4">4: Automata variant equivalent examples</h2>
        </div>

        <div>
          <h2 id="section_5">5: Closing thoughts and additional remarks</h2>
        </div>
      </article>
    </main>
  </body>
</html>
