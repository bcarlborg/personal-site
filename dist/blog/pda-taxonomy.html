<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/global-styles.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-woo-guy-32-32.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-woo-guy-96-96.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="180x180"
      href="/assets/favicon-woo-guy-180-180.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="og:title" content="Parsers (and Encoders) Everywhere" />
    <meta
      name="og:description"
      content="The personal website of Beau Carlborg" />
    <title>Taxonomy of Push Down Automata</title>
  </head>

  <body>
    <header>
      <a href="/index.html">⏎ back home</a>
    </header>
    <main>
      <article>
        <h1>⚠️Work in progress⚠️</h1>
        <p>
          I am currently in the process of writing this article. What you see
          here is merely a draft. If you stumbled across this article somehow,
          no worries, I have nothing to hide here. But know that what you see
          here is incomplete and is subject to frequent and dramatic changes in
          a way that a published article would not be.
        </p>
        <h1>Taxonomy of Push Down Automata</h1>
        <i>
          Originally Authored: July 2023 | Last Updated: July 2023 | Reading
          time: ~30 min | Author: Beau Carlborg
        </i>
        <p>
          Article contents:
          <br />
          <a href="section-1">1: Push Down Automata</a>
          <br />
          <a href="section-2">2: Components of a PDA Definition</a>
          <br />
          <a href="section-3">3: PDA Variant: The Base PDA</a>
          <br />
          <a href="section-4">
            4: PDA Variants: Multi & Optional Char Popping PDAs
          </a>
          <br />
          <a href="section-5">5: Empty Stack Acceptance PDAs</a>
          <br />
          <a href="section-6">6: Closing thoughts and additional remarks</a>
          <br />
          <a href="section_7">
            Appendix: Symbols and Notation used in this Document
          </a>
        </p>

        <div>
          <h2 id="section_1">1: Push Down Automata</h2>

          <p>
            Push down automata (PDAs for short) are a specific model of
            automata.
          </p>

          <p>
            Automata are abstract theoretical machines that are useful model fof
            computation. In general, these automata consume some input sequence
            of symbols and either accept or deny that sequence of symbols. While
            the automata consumes consumes characters from its input tape, it
            may update some internal state or store some data.
          </p>

          <p>
            There are many different variants of automata, each with their own
            bells and whistles. Some may have particular kinds of memory, and
            other may have the ability to move forwards or backwards on the
            input string. Each of these different automata variants is useful
            for modeling some type of computation problem we might be interested
            in solving.
          </p>

          <p>
            Push down automata are one such variant. They are a particular kind
            of automata with a finite state machine and an infinitely large
            stack memory. They are a useful model of computation for describing
            a number of important programming tasks like parsing programming
            languages.
          </p>

          <p>
            PDAs are covered in most books on computer science theory and
            compilers because of this applicability. While PDAs are covered
            extensively, in a number of books. the treatments can be confusing
            because each book uses a slightly different PDA definition.
          </p>

          <p>
            Each of these definitions yields a slightly different form of PDA.
            In one sense these slight differences are inconsequential because
            the variants can be shown to be equivalent in computational power,
            but the variations can be tricky for someone new to the subject, and
            may trip up a reader who is expecting more consistent
            cross-reference definitions.
          </p>

          <p>
            So, in this post, I will discuss the different PDA variants that you
            might come across while researching the topic. I will begin by
            introducing a lightweight framework for the sort of information any
            PDA definition must include. Then I will go over some PDA variants
            in the context of that definition.
          </p>
        </div>

        <div>
          <h2 id="section_2">2: Introducing PDA variants</h2>

          <p>
            It is worth re-emphasizing that PDAs are only a theoretical model of
            computation, as such, it is entirely up to us to define what they
            are and how they work using tools from mathematics. In papers and
            books that cover push down automata, you will com across many
            slightly different approaches for defining them. Those different
            definitions yield PDAs that are all slightly different. Some may be
            able to make moves or transitions that others cannot. Others may
            need information in their definitions that is irrelevant in a
            different variants formulation. But, the variants described are only
            slightly different manifestations of the same core abstract concept
            of a push down automata.
          </p>

          <p>
            Let's take sometime to reflect on what this core push down automata
            is and then we can extract a sort of framework that describes the
            types of things we need in our PDA definition.
          </p>

          <p>
            A PDA is an abstract machine that reads symbols from an input tape.
            Every time this machine reads a symbol, it may update an internal
            Finite Control state, or write and read symbols to and from an
            internal stack. After the string is read, the automata may accept
            the input string if certain conditions are met.
          </p>

          <p>
            This is again, the core abstract idea that all push down automata
            definitions are based off of. In order to make a formal mathematical
            definition from this description, there are 4 types of information
            we need to extract and make concrete.
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              Our input tape and our stack are both collection of symbols, we
              must specify all of the characters that our automata is equipped
              to process. There are an infinite number of symbols that could
              hypothetically be fed to an automata, but our PDA must specify the
              finite collection of symbols it is capable of reading from inout
              and pushing and popping from its stack. Usually this is done by
              including two finite sets in our definition. One set of input
              symbols and one set of stack symbols.
            </li>
            <li>
              <strong>Programming:</strong>
              As our automata executes, it will read input characters, it will
              update finite state, and it will push and pop symbols on our
              stack. All of this "programming" of the automata's behavior needs
              to be described somewhere somehow. Usually, this "programming" is
              encoded into a transition function. The transition function
              specifies what our automata will do at each step. Its inputs are
              the current state, some information about the current stack, and
              some information about the current input. The transition function
              maps that current configuration to a new configuration for the
              automata. The "program execution" of the automata is a matter of
              following the transition function from one configuration to
              another.
            </li>
            <li>
              <strong>Initial Configuration:</strong>
              Often times, we need to specify some information about the
              automata's configuration before it begins running. This starting
              configuration is necessary to ensure that our automata is prepped
              to run. Usually this involves specifying a starting state and some
              starting data for the PDA's stack.
            </li>
            <li><strong>Accepting Conditions:</strong></li>
          </ol>
        </div>

        <div>
          <h2 id="section_3">PDA variant 1: the base PDA</h2>
          <p>
            I define a base PDA such that its definition is a minimal extension
            of a finite automata. After all, a push down automata is really
            nothing more than a finite automata with an additional stack of
            data. A PDA can push symbols to that stack and read symbols from
            that stack to determine its next move.
          </p>

          <p>A finite automata is defined using 5 components (a 5-tuple).</p>

          <p>
            <math display="inline">
              <mtext>(Q, Σ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>

          <p>
            In the definition above, Q is the set of all states used in the
            automaton's finite control. Σ is the set of all symbols in the input
            alphabet. δ is the transition function that specifies how the
            automata reacts to the current input symbol or current automaton
            control state.
            <math>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
            </math>
            is the initial state that the automata starts in, and
            <math>
              <mi>F</mi>
            </math>
            is the set of final states that cause the automata to accept.
          </p>

          <p>
            If we build from the definition of a finite automata, what details
            do we need to specify in order add a stack, and thus create a PDA.
          </p>

          <p>
            To begin with, we will need to define what will go on the stack. Our
            definition of a base PDA will need to specify symbols that can be
            written to, and thus read from, the stack. It might be possible to
            get away with always simply reusing the input tape symbols, but
            defining them separately gives us more flexibility (footnote: I am
            not even sure if the PDA would be powerful enough if we only used
            the input symbols).
          </p>

          <p>
            We will use the character
            <math><mi>Γ</mi></math>
            to refer to this set of stack symbols in our definition.
          </p>

          <p>
            We also need a way to specify how data is written to and read from
            the stack in our definition. We can do this by including stack
            symbols in the input and output of our transition function. the
            stack symbol in the input of the function will be recognized just
            like a symbol from the input is, and a stack symbol in the output
            will be written to the stack at the end of a transition. In order to
            do this, we will need to update the type of our function
            <math><mi>δ</mi></math>
            .
          </p>

          <p>
            Our finite automata transition function had the following type (TODO
            insert). Our push down automata transition function will be
            specified as
            <math><mi>δ: Q x Σ x Γ → P(Q x Γ*)</mi></math>
            (TODO include epsilons)
          </p>

          <p>
            This new transition function can be read as,
            <math><mi>δ</mi></math>
            is a function that takes, a state, an input symbol, and a stack
            symbol as input, and outputs many pairs of a state and a string
            stack symbols.
          </p>

          <p>
            Another way of interpreting the transition function
            <math><mi>δ</mi></math>
            is that it specifies how on every single move, a character from
            input and from the stack are read, and depending on those values, a
            string is pushed onto the top of the stack.
          </p>

          <p>
            In the interest of keeping our push down automata "simple," I've
            chosen to specify it such that on transition, a character is popped
            from the stack, and multiple characters can be pushed onto the
            stack. This gives the base PDA a very consistent execution in which
            every transition is uniform to a certain degree.
          </p>

          <p>However, this transition function has two quirky aspects.</p>

          <p>
            First, on every step, the PDA can only pop one character, but it can
            push many characters or no characters. Why have that discrepancy? It
            is a concession we must make for the simplicity of always popping
            one character in a transition. Take a moment to consider -- when we
            always pop a character, we need to be able push 0 characters on a
            turn or push many characters on a turn in order to shrink and grow
            the stack respectively.
          </p>

          <p>
            Second, because our transition function requires that every step pop
            a symbol from the stack, our PDA cannot start with an empty stack.
            If our program had an empty stack to begin with, then, by
            definition, there would be no viable first transition to get things
            going. We can get around think kink by introducing another field to
            our definition: a stack start symbol. We will represent this
            character as
            <math>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
            </math>
            . By specifying a default first character, we can ensure that we
            have a toe hold into running our first transition.
          </p>

          <p>
            now that we have introduced (concepts) we can tie this all together
            into a definition.
          </p>

          <p>
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>
        </div>

        <div>
          <h2 id="section_4">
            4: PDA Variants: Multi & Optional Char Popping PDAs
          </h2>

          <p>description of Multi & Optional char popping PDAS</p>
        </div>

        <div>
          <h2 id="section_5">5: Empty Stack Acceptance PDAs</h2>

          <p>description of Multi & Optional char popping PDAS</p>
        </div>

        <div>
          <h2 id="section_6">6: Closing thoughts and additional remarks</h2>
        </div>

        <div>
          <h2 id="section_7">
            Appendix: Symbols and Notation used in this Document
          </h2>
          <ul>
            <li>
              <math><mi>δ</mi></math>
              = lower case delta
            </li>
            <li>
              <math><mi>ɛ</mi></math>
              = lower case epsilon
            </li>
            <li>
              <math><mi>Σ</mi></math>
              = upper case sigma
            </li>
            <li>
              <math><mi>Γ</mi></math>
              = upper case gamma
            </li>

            <li>
              <math><mi>A x B</mi></math>
              = the set containing all possible pairs with one element from A
              and one from B -- known as the cartesian product of A and B
            </li>
            <li>
              <math><mi>P(A)</mi></math>
              = the set containing all subsets of A -- known as the power set of
              A
            </li>
          </ul>
        </div>
      </article>
    </main>
  </body>
</html>
