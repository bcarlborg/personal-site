<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/global-styles.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-woo-guy-32-32.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-woo-guy-96-96.png" />
    <link
      rel="icon"
      type="image/png"
      sizes="180x180"
      href="/assets/favicon-woo-guy-180-180.png" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="og:title" content="Parsers (and Encoders) Everywhere" />
    <meta
      name="og:description"
      content="The personal website of Beau Carlborg" />
    <title>Taxonomy of Push Down Automata</title>
  </head>

  <body>
    <header>
      <a href="/index.html">⏎ back home</a>
    </header>
    <main>
      <article>
        <h1>⚠️Work in progress⚠️</h1>
        <p>
          I am currently in the process of writing this article. What you see
          here is merely a draft. If you stumbled across this article somehow,
          no worries, I have nothing to hide here. But know that what you see
          here is incomplete and is subject to frequent and dramatic changes in
          a way that a published article would not be.
        </p>
        <h1>Taxonomy of Push Down Automata</h1>
        <i>
          Originally Authored: July 2023 | Last Updated: July 2023 | Reading
          time: ~30 min | Author: Beau Carlborg
        </i>
        <p>
          Article contents:
          <br />
          <a href="section-1">1: Push Down Automata and their Variants</a>
          <br />
          <a href="section-2">2: Components of a PDA Definition</a>
          <br />
          <a href="section-3">3: Single Character Popping PDAs</a>
          <br />
          <a href="section-4">4: Multi-Character Popping PDAs</a>
          <br />
          <a href="section-5">5: Empty Stack Accepting PDAs</a>
          <br />
          <a href="section-6">6: Closing Thoughts and Additional Remarks</a>
          <br />
          <a href="section_7">
            Appendix: Symbols and Notation used in this Document
          </a>
        </p>

        <div>
          <h2 id="section_1">1: Push Down Automata and their Variants</h2>
          <p>
            Push down automata (PDAs for short) are a specific model of
            automata.
          </p>

          <p>
            Automata are abstract models of computers. They are theoretical
            machines, defined using mathematical concepts, which allow us to
            model computation. An automata can model a program in a manner
            similar to how calculus and physics can model the movement of a ball
            tossed through the air. In the same way that studying physics with
            calculus can help us understand the physical world, studying
            automata can help us understand our programs and software.
          </p>

          <p>
            Automata can take many forms, but often in the context of computer
            science we discuss string recognizing automata. These can be
            imagined as machines that process a sequence of characters. Once all
            of the characters are processed, the automata either accepts or
            denies the string. This simple form of machine proves to be a
            surprisingly useful abstraction for most software.
          </p>

          <p>
            There are many different forms of string recognizing automata, each
            with varying capabilities and power. Often, teh key distinction
            between different forms of automata is the memory that the automata
            can utilize. The simplest automata like finite state machines may
            have only one memory cell whose value is determined by following a
            graph structure of states based on the input characters read by the
            automata. Other more powerful automata like turing machines have an
            infinitely large memory that can be filled with any number of
            predefined symbols. Each of these forms of automata is capable of
            modeling some class of computational problems.
          </p>

          <p>
            Push down automata are a form of automata that sits somewhere in the
            middle of the total hierarchy of automata forms. A PDA has one
            memory cell controlled with a finite state control graph (like the
            finite automata) as well as an infinite memory store structured as a
            stack., where elements can only be read from or written to the top
            of the stack. Their infinite memory gives them more power than the
            simpler automata like a finite automata, but the restricted form of
            the stack memory makes them less capable than an automata like a
            turing machine.
          </p>

          <p>
            Push Down automata, with their odd restricted stack memory, may seem
            to be the [word: odd] middle child of the theoretical computation
            landscape, but they are of surprising practical importance. Push
            down automata prove to be excellent models for many computational
            problems fo great importance. PDA's model programs that straddle the
            line dividing easy and hard computational problems. A program that
            can be modeled by a PDA can often be solved quite efficiently, but a
            problem to difficult to be solved with a push down automata may be
            difficult to solve in a reasonable time frame. Many computational
            problems of practical importance like parsing a programming language
            or a depth first search of a tree can be modeled with a push down
            automata.
          </p>

          <p>
            PDAs are often given at least a chapter's worth of focus in books
            covering theoretical computer science. A typical coverage of PDAs
            will introduce a definition of a nondeterministic push down
            automata, give a few example PDAs, provide a proof of equivalence
            with context free grammars, and maybe introduce deterministic push
            down automata.
          </p>

          <p>
            I have struggled with the coverage of push down automata in a number
            of resources because I failed to fully grasp the initial definition
            that the content build on. I have two theories about why these
            definitions were difficult to wrap my head around.
          </p>

          <p>
            Firstly, there are a handful of different PDA definition in use
            across different books on the subject. While all of these
            definitions are quite similar adn define variants that are
            computationally equivalent, the variety can be disorienting. The
            definitions all yield slightly different push down automata variants
            with their own subtleties. It took me longer than I would like to
            admit, to realize that these different variants were in use. It took
            me even longer to internalize teh difference in the definitions and
            feel comfortable switching between them.
          </p>

          <p>
            Secondly, I feel that push down automata are simply peculiar. PDAs
            have neither the austere simplicity of a finite state machine, nor
            the all encompassing flexibility of a turing machine. Instead, they
            are an automata with a somewhat awkward stack memory structure whose
            restrictions can be tricky to capture using a mathematical
            definition. Defining PDAs often involves additions to our
            definitions like stack based symbols that just seem awkward.
          </p>

          <p>
            It is because of my trouble with these definitions that I wanted to
            write this post. Overtime, I was able to develop my own mental model
            for organizing and thinking about these definitions that helped me
            build a conceptual foundation for PDAs and begin to understand the
            more interesting results about this automata.
          </p>
        </div>

        <div>
          <h2 id="section_2">2: Components of a PDA Definition</h2>

          <p>
            It is worth re-emphasizing that PDAs are only a theoretical model of
            computation, as such, it is entirely up to us to define what they
            are and how they work using tools from mathematics. The most common
            definitions of push down automata primarily use sets of symbols and
            functions over those sets as the building blocks of a PDA
            definition.
          </p>

          <p>
            A typical automata definition may look something like this:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
            . This definition is a collection of 7 symbols that each represent
            some set, function, or symbol. Taken together, the symbols are a
            7-tuple that specifies a particular push down automata.
          </p>

          <p>
            At first encounter, it may not even seem possible that a series of
            symbols representing sets and functions can define an abstract
            computer. It is not a particularly intuitive representation.
          </p>

          <p>
            To understand a definition like this, I think that it is productive
            to think about the types of information that must be included in an
            automata representation. To think about the broad types of
            information that need to be formalized, then figure out how the
            symbols fit into those categories.
          </p>

          <p>
            Our automata is akin to a program on a computer in more than just an
            abstract sense. I find that using a similar mental model for
            specifying programs is useful for specifying and automata.
          </p>

          <p>
            When we consider a program, we need to know about the program's:
          </p>

          <ul>
            <li>
              <strong>character set:</strong>
              What symbols are used to represent the program and how are they
              encoded. Is the program a sequence of unicode characters? or a
              binary blob composed of 16 bit machine code instructions.
            </li>

            <li>
              <strong>static data or initial configuration:</strong>
              Programs are not just code, the programs include static data that
              the program references. Information like the default values for
              variables and constants all need to be specified in the program
              data itself.
            </li>

            <li>
              <strong>program code:</strong>
              The actual instruction that the program executes. These
              instructions define the program's behavior and control flow.
            </li>

            <li>
              <strong>accepting / terminating conditions:</strong>
              When is the program done, and how do we interpret its results,
              does the program write a certain value to the stdout, does it set
              some register to indicate it was successful? We need a way to
              interpret the output of our program and determine wether it was
              successful or unsuccessful.
            </li>
          </ul>

          <p>
            We can app;y this same mental model of a program's content to the
            definition of a push down automata. The information in our PDA
            definition or specification needs to explain:
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              As mentioned before, a PDA processes an input string, and writes
              and reads data from an internal stack. Our input tape and our
              stack are both collection of symbols, we must specify all of the
              characters that our automata is equipped to process.
            </li>

            <li>
              <strong>Programming:</strong>
              As our automata executes, it will read input characters, it will
              update finite state, and it will push and pop symbols on our
              stack. This behavior can be encoded using a function that
              describes how the automata updates its internal state as new
              characters are processed.
            </li>

            <li>
              <strong>Initial Configuration:</strong>
              Just like a program, our PDA also may have some initial
              configuration or default values. PDA's specify an initial control
              state and may have some initial data on their stack in order to
              kick off their execution properly.
            </li>

            <li>
              <strong>Accepting Conditions:</strong>
              Finally, we need to specify the conditions with indicate our PDA
              has accepted a string. These conditions will be based on some
              aspect of the push down automata's internal data (finite control
              and the stack).
            </li>
          </ol>

          <p>
            Every symbol in our definition helps helps to specify one of the
            above aspects of our program. Understanding the formal definitions
            of push down automata is a matter of internalizing how each symbol
            and its value informs one of the above qualities in our definition.
          </p>

          <p>
            To make things more concrete, we will explain a few common PDA
            definition variants and show how each fits into this little
            framework.
          </p>
        </div>

        <div>
          <h2 id="section_3">3: Single Character Popping PDAs</h2>

          <p>
            The first PDA variant we will introduce is one which has a very
            simple transition mechanism. This PDA always pops a single character
            off the top of its stack on every transition. This behavior creates
            a PDA with a very regular and consistent behavior. However,
            achieving this consistency on every transition does require a few
            awkward additions in the rest of our PDA definition.
          </p>

          <p>
            The first awkward aspect of this PDA is the discrepancy between the
            pushing and popping. In order for this base PDA to function
            properly, we must have the ability to push zero or many characters
            back onto the stack at every transition. This additional capability
            in the pushing step is necessary so that we can fully utilize our
            stack. Every PDA must be able to change the size of its stack during
            execution, wether by adding new characters and increasing its size,
            or removing characters and decreasing its size. Because our PDA pops
            one character on every transition, in order to grow the stack, we
            must have the ability to push more than one character on every turn,
            and in order to shrink the stack we must have the ability to push no
            characters onto the stack.
          </p>

          <p>
            And so, when we wish to add a new character onto the stack, we must
            pop the current top character, then in the next step push on a two
            character string composed of the character we just popped followed
            by the new character we wish to add. On transitions in which we wish
            to keep the stack the same, we must pop the current top of the
            stack, then push the same character back onto the stack. This setup
            has always felt a bit awkward to me, but it is necessary.
          </p>

          <p>
            In order to support single character popping on every transition, we
            also need to make an addition to our PDAs initial configuration. We
            must add a starting stack character to our definition of a PDA.
            Every transition our PDA makes requires there already be one
            character to pop, and so, in order for our first transition to
            function, we must already have one character on the stack.
          </p>

          <p>
            Now, we can put together a complete PDA definition in the
            organization of the framework introduced above.
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              This PDA has two sets of character we are concerned with, the
              character set of the input and of the stack,
              <math display="inline">
                <mtext>Σ</mtext>
              </math>
              and
              <math display="inline">
                <mtext>Γ</mtext>
              </math>
              respectively. Each of these refers to a simple set of symbols.
            </li>

            <li>
              <strong>Programming:</strong>
              the programming of this PDA consists of its set of finite states
              as well as a transition function. Our set of finite states will be
              represented by the set
              <math display="inline">
                <mtext>Q</mtext>
              </math>
              and our transition function will be represented by the symbol
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              .
              <math display="inline">
                <mtext>Q</mtext>
              </math>
              is a Simple set of symbols, and
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              is a transition function of the form
              <math><mi>δ: Q x { Σ ∪ ɛ } x Γ → P(Q x Γ*)</mi></math>
              . This can be read as saying, the transition function
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              takes 3 inputs: a required current state, an optional current
              input character, and a required symbol at the top of the stack.
              The function's output is a set of state and stack symbol string
              pairs.
            </li>

            <li>
              <strong>Initial Configuration:</strong>
              Our definition must include two initial configuration values. Like
              any finite state machine, we must include a starting state
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
              </math>
              where
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
                <mtext>∊ Q</mtext>
              </math>
              . As mentioned above, for this particular push down automata
              variant, we also must include a starting stack symbol
              <math display="inline">
                <msub>
                  <mi>Z</mi>
                  <mn>0</mn>
                </msub>
              </math>
              where
              <math display="inline">
                <msub>
                  <mi>Z</mi>
                  <mn>0</mn>
                </msub>
                <mtext>∊ Γ</mtext>
              </math>
            </li>

            <li>
              <strong>Accepting Conditions:</strong>
              finally, we must specify the acceptance conditions for this PDA.
              Much like finite automata, this PDA uses a set of accepting state
              conditions
              <math display="inline">
                <mtext>F</mtext>
              </math>
              where
              <math display="inline">
                <mtext>F ⊆ Q</mtext>
              </math>
              . If the PDA is one of of these states when the full input has
              been read, then the PDA accepts the current string.
            </li>
          </ol>

          <p>
            We can put all of these values together into a 7 components tuple (a
            7-tuple).
          </p>

          <p>
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>

          <p>
            Any base PDA that we will to define will need to specify values for
            these 7 properties.
          </p>
        </div>

        <div>
          <h2 id="section_4">4: Multi-Character Popping PDAs</h2>

          <p>
            Another common form of PDA definition is one in which the PDA has
            the ability to pop zero or many characters on each transition step.
            This is a natural extension from the base PDA, and can make the
            programming of the PDA much simpler.
          </p>

          <p>
            In addition to adding a bit of flexibility to our PDA transition
            function, this construction also feels a bit more elegant than the
            single popping PDA. For one, this variant has a nice symmetry
            between the characters pushed and popped and does not require the
            awkward practice of pushing back the character you popped when you
            which to add a new character to the stack. Even better though, this
            variant removes the need for the start symbol on our stack. We added
            the start symbol to accommodate the requirement that every
            transition pops a character, but this variant has no such
            requirement, and so we can remove that from our definition
          </p>

          <p>
            Let's put down a definition for multi character popping PDAs using
            the same framework again.
          </p>

          <ol>
            <li>
              <strong>Character sets:</strong>
              Just like the previous PDA variant, this PDA has two character
              sets we care about, the input symbols and the stack symbols,
              <math display="inline">
                <mtext>Σ</mtext>
              </math>
              and
              <math display="inline">
                <mtext>Γ</mtext>
              </math>
              respectively.
            </li>

            <li>
              <strong>Programming:</strong>
              Just as before, this PDA will have a set of states,
              <math display="inline">
                <mtext>Q</mtext>
              </math>
              , for its finite state control. The transition function for this
              PDA will be similar to the last, but will include information that
              allows for popping multiple symbols on every transition. Again,
              this transition function will be represented by the symbol
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              . This transition can be formally defined as is a transition
              function of the form
              <math><mi>δ: Q x { Σ ∪ ɛ } x Γ* → P(Q x Γ*)</mi></math>
              . This can be read as saying, the transition function
              <math display="inline">
                <mtext>δ</mtext>
              </math>
              takes 3 inputs: a required current state, an optional current
              input character, and a string of zero or many stack symbols from
              the top of the stack. The function's output is a set of state and
              stack symbol string pairs.
            </li>

            <li>
              <strong>Initial Configuration:</strong>
              This PDA variant will require a starting finite control state just
              as before. Again this start state will be
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
              </math>
              where
              <math display="inline">
                <msub>
                  <mi>q</mi>
                  <mn>0</mn>
                </msub>
                <mtext>∊ Q</mtext>
              </math>
              . This PDA variant will not require a starting stack symbol as our
              first PDA variant did.
            </li>

            <li>
              <strong>Accepting Conditions:</strong>
              finally, we must specify the acceptance conditions for this PDA.
              These will be the same set of accepting states as were defined for
              the base PDA above.
              <math display="inline">
                <mtext>F</mtext>
              </math>
              where
              <math display="inline">
                <mtext>F ⊆ Q</mtext>
              </math>
              .
            </li>
          </ol>

          <p>
            We can put all of these values together into a 6 components tuple (a
            6-tuple).
          </p>
          <p>
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Q</mi>
                <mn>F</mn>
              </msub>
              <mi>)</mi>
            </math>
          </p>
        </div>

        <div>
          <h2 id="section_5">5: Empty Stack Accepting PDAs</h2>
          <p>
            The final PDA variant we will consider is one that is often
            introduced in the latter half of text book chapters on PDAs. Unlike
            the previous variants we have considered, which all make
            modifications on the transition function itself, this variant makes
            a modification to the acceptance conditions used by the PDA. Instead
            of using a set of final states in the finite control unit, this PDA
            accepts a string when the input is fully read, and the PDA's stack
            is empty.
          </p>

          <p>
            To apply this change to our definition, we only need to specify that
            an empty stack is an accepting condition. This is simple enough to
            express in an english sentence, but can be tricky to write out
            formally. Most books on the subject choose to simply specify the
            acceptance condition in a sentence.
          </p>

          <p>
            We could make either of the PDA's we've defined so far an empty
            stack acceptance PDA by simply removing the final states from their
            definition and specifying that they accept with empty stacks.
          </p>

          <p>
            So a single character popping PDA with empty stack acceptance would
            be defined with the 6-tuple:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>,&#xA0;</mi>
              <msub>
                <mi>Z</mi>
                <mn>0</mn>
              </msub>
              <mi>)</mi>
            </math>
            with a note specifying that it accepts when the stack is emptied.
          </p>

          <p>
            And a multi character popping PDA with empty stack acceptance would
            be defined with the 5-tuple:
            <math display="inline">
              <mtext>(Q, Σ, Γ, δ,&#xA0;</mtext>
              <msub>
                <mi>q</mi>
                <mn>0</mn>
              </msub>
              <mi>)</mi>
            </math>
            with a note specifying that it accepts when the stack is emptied.
          </p>
        </div>

        <div>
          <h2 id="section_6">6: Closing Thoughts and Additional Remarks</h2>
        </div>

        <p><strong>Why choose one definition over the other?</strong></p>

        <p>
          Ultimately it comes down to your goals. Some variants are better for
          representing certain proofs, others are easier to program. It is not
          that different from choosing one programming language over the other.
          Usually, each language can achieve the same end results, but it comes
          down to how well suited that language is for the task.
        </p>

        <p><strong>Are these variants truly interchangeable?</strong></p>

        <p>
          Computationally, yes, these are interchangeable, in that each of the
          PDA variants can accept every language that another PDA variant would.
          In terms of complexity, the situation is a bit more complicated. Some
          of the machines can represent the an automata for the same language
          with different complexity properties. The multi popping PDA in
          particular is slightly better at hiding complexity than the others.
        </p>

        <p><strong>How could we prove they are equivalent?</strong></p>

        <p>
          The process of proving that two automata variants are equivalent comes
          down to showing that any language that can be accepted by an automata
          in the style of variant A can also be accepted by an automata in the
          style of variant B and vice versa.
        </p>

        <p>
          Most textbooks that cover push down automata give specific examples of
          this process and how it can work.
        </p>

        <p>
          <strong>
            Which books have you been referencing to learn about PDAs:
          </strong>
        </p>
        <p>
          Many... but these are a few i like with a note about their style and
          quality:
        </p>
        <ol>
          <li>book 1: notes about style</li>
          <li>book 2: notes about style</li>
          <li>book 2: notes about style</li>
        </ol>

        <div>
          <h2 id="section_7">
            Appendix: Symbols and Notation used in this Document
          </h2>
          <ul>
            <li>
              <math><mi>δ</mi></math>
              = lower case delta
            </li>
            <li>
              <math><mi>ɛ</mi></math>
              = lower case epsilon
            </li>
            <li>
              <math><mi>Σ</mi></math>
              = upper case sigma
            </li>
            <li>
              <math><mi>Γ</mi></math>
              = upper case gamma
            </li>

            <li>
              <math><mi>A x B</mi></math>
              = the set containing all possible pairs with one element from A
              and one from B -- known as the cartesian product of A and B
            </li>
            <li>
              <math><mi>P(A)</mi></math>
              = the set containing all subsets of A -- known as the power set of
              A
            </li>
          </ul>
        </div>
      </article>
    </main>
  </body>
</html>
