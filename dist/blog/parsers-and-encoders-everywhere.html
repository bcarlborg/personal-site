<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/global-styles.css" />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/assets/favicon-woo-guy-32-32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="96x96"
      href="/assets/favicon-woo-guy-96-96.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="180x180"
      href="/assets/favicon-woo-guy-180-180.png"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="og:title" content="Parsers (and Encoders) Everywhere" />
    <meta
      name="og:description"
      content="The personal website of Beau Carlborg"
    />
    <title>Parsers (and Encoders) Everywhere</title>
    <title>Beau Carlborg</title>
  </head>

  <body>
    <header>
      <a href="/index.html">⏎ back home</a>
    </header>
    <main>
      <article>
        <h1>Parsers (and Encoders) Everywhere</h1>
        <i>
          Originally Authored: June 2023 | Last Updated: June 2023 | Reading
          time: ~30 min | Author: Beau Carlborg
        </i>
        <p>
          Article contents:
          <br />
          <a href="#1-encountering-and-attempting-to-learn-parsers">
            1: Encountering and attempting to learn parsers
          </a>
          <br />
          <a href="#2-coming-to-see-parsers-broad-applicability"
            >2: Coming to see parser's broad applicability</a
          >
          <br />
          <a href="#3-parsers-and-encoders-in-the-real-world"
            >3: Parsers and encoders in the real world</a
          >
          <br />
          <a href="#4-takeaways">4: Takeaways</a>
        </p>
        <hr />
        <p>
          In this article, I'd like to describe my experience learning about
          parsers.
        </p>
        <p>
          Parsers are components in software that allow programs to extract
          structured data encoded in a string or byte array (if you don’t know
          what that means, don’t worry! We will discuss what parsers are at
          length in this post).
        </p>
        <p>
          After I was introduced to parsers, I wanted to learn everything about
          them. I wanted to know the best approaches for building parsers. I
          wanted to understand how different parsing algorithms stack up against
          each other. I wanted to develop an intuition for the mechanism that
          really makes a parser tick.
        </p>
        <p>
          As it turns out, understanding parser is a tricky business. There is a
          lot of theory involved, and the resources available to go deep into
          parsing terse. I spent many months learning about parsers, and I did
          not find the understanding I was looking for and to this day, I can’t
          say that I really “get” parsers.
        </p>
        <p>
          But somewhere along the way, I had a realization about how parsers can
          be used that led me to see their wide ranging applicability in
          software. It was one of those realizations that seems simple on the
          surface, but fundamentally changes your perception. This realization
          came as a surprise to me, because I still hadn’t “learned parsers” in
          the way I expected to.
        </p>
        <p>
          In this post, I’ll put that realization into words and detail how I
          came to it. This is a long and casual read. I hope you enjoy it.
        </p>
        <h2 id="1-encountering-and-attempting-to-learn-parsers">
          1: Encountering and attempting to learn parsers
        </h2>

        <p>
          I encountered parsers as a topic worth studying while learning about
          compilers.
        </p>
        <h3>Parsers: a phase in a compiler</h3>

        <p>
          Compilers, and their siblings like interpreters and virtual machines,
          are the family programs that transform software written in high level
          languages like C, python, and Java into binary instructions that run
          on a specific computer. Compilers specifically are programs that take
          the text of a program in a language like C as input and transform that
          program into a binary executable file that can be run on a computer.
        </p>
        <p>
          Compilers are organized as a series of phases which can be grouped
          into the compiler’s frontend and backend. The frontend is responsible
          for processing the text of your program while the backend is
          responsible for optimizing your program and outputting instructions
          for the target machine.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image1.png"
            alt="compiler phases with distinction highlighting frontend and backend phases"
            title=""
          />
        </p>
        <p>
          Within the compiler frontend, two phases are responsible for
          extracting structure from the input programs text; these are the lexer
          and parser.
        </p>
        <p>
          The lexer processes aprogram's text character by character, and
          outputs a stream of tokens. It transforms our program by grouping the
          input characters together into a series of tokens. The lexer passes
          these tokens to the parser, which builds an abstract syntax tree
          representing the program's structure.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image2.png"
            width=""
            alt="input string being transformed by lexer into token stream, that token stream is then transformed by a parser into a tree"
            title=""
          />
        </p>
        <p>
          At the risk of sounding dramatic, I believe that the parser’s task is,
          in its own way, miraculous. The parser extracts a multi-dimensional
          structure out of a simple one dimensional list of tokens. Other
          compiler phases may apply transformations to that structure, but it is
          the parser that bootstraps the compiler up from a meager ol' list of
          words to a meaningful representation of a program.
        </p>
        <h3>Down the parsing rabbit hole</h3>

        <p>
          Parsing completely captured my interest. There are many other
          fascinating phases of compilers worth diving into, but I wanted to
          deeply understand parsers, and I would spend as much time as I needed
          to do it.
        </p>
        <p>
          Most compiler resources cover parsers in some depth, and so I began
          there. Some of the books hold your hand through a parser
          implementation or two, others teach you how to use a parser generator.
          Some give a brief overview of the theory that backs parsers, and
          others forgo the theory entirely. While working through these
          resources, I was learning the names of the parsing algorithms, and I
          was absorbing some of the acronyms and jargon... but the essence of
          parsing remained elusive.
        </p>
        <p>
          Unsatisfied with the compiler resources, I decided to take some steps
          back and view the problem at a high level. I would try to find
          generic, non-compiler related resources on parsing. If you search
          around for a definition of a parser in the context of computer
          science, you are very likely to find something along the lines of:
        </p>
        <p>
          <strong
            >Parsers are software components or programs that analyze input data
            by following a set of predefined rules or patterns. Their main
            objective is to examine a sequence of symbols or tokens and
            understand their intended structure and meaning.</strong
          >
        </p>
        <p>
          Reading a definition like this, we see that a parser takes a stream of
          input characters and outputs something that is structured and
          meaningful. I feel that broad definitions like these are scant on
          details and lend parsers an almost mystic quality… Parsers find
          meaning in symbols. Parsers extract structure from the structureless.
          Parsers extract meaning and truth from all. Parsers are the one ring
          to rule them all.
        </p>
        <p>
          Needless to say, I was going to need resources that went into more
          depth, but remained independent of compilers.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image3.png"
            alt="parser transforming random stream of tokens and input symbols from a number of non english character sets into the phrases 'mearning? structure? semantics? truth? liberation? who knows?'"
            title=""
          />
        </p>
        <p>
          Seeking a deeper intuition for parsing, I decided to explore the
          theory that underpins parsers. (This line of exploration turned out to
          be a deep rabbit hole that I would spend a lot of time climbing out
          of.)
        </p>
        <p>
          Parsers are, at their core, a way to process text. There are two
          interconnected theories that form the basis for parsers. Formal
          language theory: a field concerned with how text is structured with
          grammars to form languages, and automaton theory: a field about
          abstract computing machines that process input streams of text.
        </p>
        <p>
          These two fields provide the theoretical backdrop for parsers and I
          felt like this theory would be a good place to really learn what
          parsers are all about. So I decided to read books, articles, and
          papers about parsers in this theoretical context.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image4.png"
            alt="cartoon depiction of a number of books related to parsing theory. Books include 'On Certain Properties of Grammars' by Noam Chompsky, 'On Computable Numbers' by Alan Turing, 'Formal Languages and their Relation to Automaton' by Jeffrey Ulman and John Hopcroft, and 'Syntax in Universal Translation' byt Itiroo Sakai"
          />
        </p>
        <p>
          From formal language theory, I was reading about grammar, syntax, and
          semantics, trying to learn how different grammar constructions define
          certain classes of languages. From automaton theory, I was reading
          about finite state machines, push down automata, turing machines, and
          all of their deterministic and non-deterministic variants.
        </p>
        <p>
          Learning the theory behind parsing gave me a new vocabulary and set of
          tools for describing and classifying parsers. The reading I was doing
          helped me see how parsers are intimately tied with specific automata
          and specific grammars. The theory taught me a great deal, but I had
          strayed too far from my initial application and I wasn't finding the
          applied understanding I wanted.
        </p>
        <p>
          I decided to come back from academic theory and focus on applied
          algorithms. Soon, I was comparing grammar subsets like LL, LR, SALR,
          and LALR. I was writing LL and LR parsing compatible grammars. I was
          learning about parsers defined with P.E.Gs. Again, I was learning, but
          I wasn’t grasping the underlying concepts. Perhaps this was a result
          of the alphabet soup of parsing acronyms, or maybe I had just been
          reading about parsers for too long.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image5.png"
            alt="a bowl of soup, but the soup has the following acronyms floating in it: CFG, LR(K), CYK, PDA, SALR, PDA, LALR, LL(K), PEG, BNF "
            title=""
          />
        </p>
        <p>
          None of the resources I worked through gave me the exact understanding
          I was looking for. I haven't had that “ah-ha” moment where the
          mechanism behind a parser clicks into focus.
        </p>
        <p>
          I think the core difficulty in learning parsing is that it is subject
          matter that straddles theoretical computer science and applied
          programming. Resources on the topic often are either too shallow and
          focus on teaching one parsing approach without breaching the theory,
          or are too theoretical and divorced from any real application.
        </p>
        <p>
          I believe that to truly understand parsing, one needs to understand
          how the core parsing algorithms are manifestations of the underlying
          parsing theory. While I am hopeful that one day parsers and the theory
          that underlies them will come into focus for me, that day hasn’t come
          yet.
        </p>
        <p>
          Thankfully though, I did come to an understanding that helped me see
          how broadly applicable parsers are.
        </p>
        <h2 id="2-coming-to-see-parsers-broad-applicability">
          2: Coming to see parser's broad applicability
        </h2>

        <p>
          At some point in my process of learning about parsing theory, I came
          to a realization about what parsers do. I realized that there is a
          simple definition describing parsers that highlights how they can be
          <em>used</em> rather than how they can be <em>constructed</em>.
        </p>
        <p>
          Viewing parser in this new light helped me see that parsers are
          incredibly applicable beyond compilers. I started to see that parsing,
          on some level, was incorporated into most programs I use.
        </p>
        <h3>A clarifying definition of parsing</h3>

        <p>
          <strong
            >Parsers (and their inverse: encoders) allow us to efficiently
            encode and decode complex structured data like graphs, trees, and
            dictionaries using flat data structures like strings and arrays of
            bytes.</strong
          >
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image6.png"
            alt="depiction of multiple data data structure like a nested list, a dictionary, a tree and a graph being encoded to and parsed from strings"
            title=""
          />
        </p>
        <p>
          This definition is only a slight rephrasing of other common
          definitions for parsers, but something about this particular phrasing
          really stuck with me. I want to take some time to develop the ideas
          behind it.
        </p>
        <h3>The same definition, in two parts</h3>

        <p>
          Let's break down that definition into two parts in order to really
          absorb it:
        </p>
        <p>
          Parsers (and their inverse: encoders)<strong>
            allow us to efficiently encode and decode complex structured data
            like graphs, trees, and dictionaries</strong
          >
          using flat data structures like strings and arrays of bytes.
        </p>
        <p>
          What exactly do we mean by complex structured data? When I say
          structured data, I am imagining data structures like lists, graphs,
          trees and dictionaries. I am imagining any set of data that has values
          with mixed types. Data where each datum has relationships to other
          datum.
        </p>
        <p>
          Every program, at some level, uses structured data. After all, it has
          been said that
          <a
            href="https://en.wikipedia.org/wiki/Algorithms_%2B_Data_Structures_%3D_Programs"
            >programs = data structures + algorithms</a
          >. In many ways, all software simply creates, modifies or exports
          structured data based on program inputs and external events.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image7.png"
            alt="Image depicting a tree being updated in response to multiple user events"
            title=""
          />
        </p>
        <p>Now let’s turn to the second part of the definition:</p>
        <p>
          Parsers (and their inverse: encoders) allow us to efficiently encode
          and decode complex structured data like graphs, trees, and
          dictionaries
          <strong
            >using flat data structures like strings and arrays of
            bytes.</strong
          >
        </p>
        <p>
          Why are we so focused on strings and arrays of bytes? Why is it useful
          to use strings and byte arrays as a medium for our structured data?
        </p>
        <p>
          Oftentimes multiple programs need to communicate and share structured
          data with each other. The programs may share whole copies of their
          internal structure, or they may send small structured requests and
          responses. But, there is always some exchange of structured data.
        </p>
        <p>
          Programs have many interfaces available to communicate with each other
          from file IO, to sockets or shared memory. It turns out that the many
          of the common interfaces programs use to communicate with each other
          require that the data being sent is in the form of a string or byte
          array.
        </p>
        <p>
          It is because of these communication interfaces that strings and byte
          arrays are so relevant.
        </p>
        <p>
          Our programs want to communicate structured data with each other, but
          they only have the ability to send strings and arrays. Parsers and
          encoders are what will allow our programs to transform their
          structured data into those strings and arrays and back.
        </p>
        <h3>Two programs communicating with strings</h3>

        <p>
          It may belabor the point a bit for some readers, but I want to linger
          on the idea that parsers and encoders allow programs to communicate
          structured data using string and byte array interfaces. This idea may
          seem obvious and it may not seem worth spending time on, but deeply
          considering this thought helped see that parsers and encoders are
          essential in almost all software.
        </p>
        <p>
          We’ll examine the relationship between programs, interfaces, and
          parsers & encoders by looking at multiple situations in which two
          abstract programs might need to communicate. I hope these examples
          will instill the idea that most interfaces necessitate that programs
          use some form of parsers and encoders.
        </p>
        <p>
          Let's begin by considering two programs, A and B, running on the same
          computer. These programs want to communicate some structured data to
          each other using the operating system. With the interfaces that the OS
          provides -- like sockets, files, and pipes -- the message our programs
          transmit and receive will need to be strings or arrays of bytes.
          Because of this, the<strong>
            programs will need to leverage an encoder and parser in order to
            convert the structured data to and from strings.</strong
          >
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image8.png"
            alt="depiction of Program A using an encoder to send a data structure to program B through an operating system interface. Program B uses a parser to read that data"
            title=""
          />
        </p>
        <p>
          Let's consider a similar, but slightly different example: consider two
          programs running on separate machines that want to communicate. The
          operating system provides interfaces for programs to do this -- likely
          some version of sockets -- and these interfaces also require that the
          data being sent is in the format of a string or array of bytes.
          <strong
            >So, yet again, the programs will need encoders and parsers.</strong
          >
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image9.png"
            alt="depiction of Program A using an encoder to send a data structure to program B through the internet. Program B uses a parser to read that data"
            title=""
          />
        </p>
        <p>
          Now let's consider two programs that do not run at the same time, but
          still, wish to communicate some information. The sending program will
          need to write the information it wants to send in a file so that the
          receiving program can open it at a later time. Files are simply long
          arrays of bytes stored in a device that gives them persistence, so
          again, parsers and encoders are necessary.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image10.png"
            alt="depiction of Program A using an encoder to send a data structure to program B through a file. Program B uses a parser to read that data"
          />
        </p>
        <p>
          In most situations in which two programs need to communicate, we are
          going to see parsers and encoders at the edges of our programs'
          functionality. These parsers and encoders are what enable the use of
          so many string / byte array based interfaces.
        </p>
        <h3>Humans and programs communicating with strings</h3>

        <p>
          All of the examples thus far have focused on situations in which
          programs need to communicate with other programs. To take things in a
          slightly more abstract direction, we can consider situations in which
          the sender is a person and the receiver a program.
        </p>
        <p>
          When a person has an idea of the structured data they want to
          communicate to a program, they can capture their message by encoding
          that structured concept into a file. This may seem odd, but it is
          actually more common than you may realize.
        </p>
        <p>
          When you are writing config files for some program like your text
          editor, or even when you are carefully assembling your arguments for
          some script on the command line, you are taking your structured
          concept about what you want the program to do and
          <strong>encoding </strong>that data into a string. Then, the program
          will take that string and <strong>parse</strong> it in order to decide
          what to do!
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image11.png"
            alt="depiction of a human manually encoding information into a file that a program then extracts using a parser"
          />
        </p>
        <p>
          We can also consider the inverse arrangement with a program
          communicating with a person using strings. This also may seem strange
          at first, but if we think abstractly, this is exactly what programs
          which write log files or provide stack traces are doing. Those
          programs are <strong>encoding</strong> some information about their
          internal state as a string in a format that a person can easily
          <strong>parse</strong> and understand.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image12.png"
            alt="depiction of a program encoding information into a file that a human then manually parses"
          />
        </p>
        <p>
          (Dear reader, as it turns out, you and I were the ones parsing and
          encoding all along 💛)
        </p>
        <h3>Seeing parsers and encoders everywhere</h3>

        <p>
          The key observation I want to highlight with all of these examples is
          that, whenever your program is communicating with anything or anyone,
          it is very likely that the program is using a string or array of bytes
          as the medium of communication. And whenever your program is
          communicating with string, there is likely a parser or encoder
          somewhere.
        </p>
        <p>
          That parser or encoder may just be a small bit of functionality at the
          edge of your program's overall purpose. It may be a library you
          imported, or it may be a handcrafted little string processor that you
          didn't even realize was a parser or encoder to begin with. But it is
          there!
        </p>
        <p>
          When that really sinks in, it becomes hard to think about programs
          that don't involve parsing or encoding. This for me, was a big
          realization. Before learning about parsers, I assumed they were just a
          phase in a compiler that may or may not be worth spending time on. But
          after learning a bit about parsers, I'm seeing parsers in almost every
          program I use. That is a big turn around.
        </p>
        <h2 id="3-parsers-and-encoders-in-the-real-world">
          3: Parsers and encoders in the real world
        </h2>

        <p>
          We've talked a lot about parsers and encoders in the context of two
          abstract programs, A and B. I have made the bold claim that parsers
          and encoders are everywhere, in all the software you use, right under
          your nose! So now, I will back up that claim by looking at some real
          world technologies and programs. We'll discuss the formats of strings
          programs use to encode structured data, and we'll discuss the kinds of
          structured data that programs encode.
        </p>
        <h3>Data serialization formats: JSON XML YAML, oh my</h3>

        <p>
          In the examples above, we looked at programs communicating with
          strings using many interfaces. However, I was a bit vague about the
          contents of those strings. I didn't describe how we represent
          structured data in a string. So let's look at the string formats that
          are used in practice to actually transmit structured data between
          programs.
        </p>
        <p>
          There are a number of formats for writing structured data in strings
          or byte arrays. These formats will likely be familiar to most software
          developers. JSON, XML, and YAML are all examples of string formats
          that allow us to encode data structures with strings. Broadly
          speaking, these formats can all be called data serialization formats
          or data exchange formats. There are also a number of data exchange
          formats that use binary as their representation medium such as
          protobuf or FlatPack.
        </p>
        <p>
          These data serialization formats provide a well defined pattern to
          represent common data structures like dictionaries and nested arrays
          in strings or binary. Two programs can effectively use one of these
          formats as a common tongue when communicating structured data. So, a
          java program can encode an ArrayList of Hashmaps into a JSON string
          and send that data to a JS program which will extract it as an array
          of objects. By using an agreed upon data serialization format, the two
          programs can be sure that the structure of the data they are sharing
          will not be lost or misinterpreted. This works even though a java
          program and a javascript program represent lists and dictionaries in
          completely different ways.
        </p>
        <p>
          Consider two programs A and B, on different machines, communicating a
          simple dictionary using JSON. These two programs could be written in
          any programming language and could internally represent that
          dictionary in any way that they please. But by using JSON, neither
          program needs to concern itself with the other program's internal
          representation of the dictionary.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image13.png"
            alt="depiction of program A using JSON.encode to transmit data to program B"
          />
        </p>
        <p>
          As mentioned above, JSON is only one option for a data serialization
          format. There are many others, each with their own set of pros and
          cons.
        </p>
        <p>
          Many of the different formats have slightly different ergonomics or
          use unique nomenclature to describe their interfaces. For example,
          when describing parsing and encoding, some formats use the terms
          'encode' and 'parse'. JSON is one such format. When using a JSON
          library, you will commonly see JSON.parse, or JSON.encode. Other
          formats use different verbs to describe this process. With some
          formats, you may see marshal and unmarshal rather than encode and
          parse. Other times, you may see serialize and deserialize. Despite the
          different words that each format uses to describe what it can do, they
          are all doing the same thing.
        </p>
        <p>
          (During the rest of the article, I will start to use the terms
          serialize and deserialize interchangeably with encode and parse. I am
          doing this mainly to add some variety to my word choice. I am not
          making any significant distinction between the two.)
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image14.png"
            alt="depiction of using the words encode, serialize and marshal interchangeably and also showing parse, deserialize, and unmarshal used interchangeably"
          />
        </p>
        <p>
          Beyond the surface level difference in jargon, there are some more
          substantial differences worth discussing between the different formats
          though. The readability of the formats, the ease with which they can
          be parsed, and the flexibility of the formats are all important
          considerations.
        </p>
        <p>
          In terms of readability, JSON strikes a nice balance between being
          easily readable by humans and programs. Consequently, it is useful for
          data that is being exchanged between programs that may need to be
          edited or viewed by a person as well. It also is a somewhat dense
          encoding, meaning that most of the characters used in a JSON string
          are significant data, fewer characters are used to capture its syntax.
          JSON is not without flaws though. There are some peculiarities within
          the JSON specification that can come around to bite an unassuming user
          (see:
          <a href="http://seriot.ch/projects/parsing_json.html"
            >Parsing JSON is a minefield 💣</a
          >). As someone who works a lot with javascript, I happen to
          particularly like the aesthetics of JSON, but many others do not 🤷
        </p>
        <p>
          Other formats can be more flexible, and may make the encoding of
          complex data structures a bit simpler. XML might be one such format. A
          format like XML may be useful for encoding data that is organized in a
          very bespoke way with many domain-specific names and relationships.
          But, XML is also very verbose. Representing simple structures in XML
          can require a lot of tags, and thus, a lot of extra data. This
          verbosity is a part of the reason that XML is no longer a stylish
          choice for a data serialization format, but there is more at work
          leading to XMLs downfall (see:
          <a href="https://wiki.c2.com/?XmlSucks">XML sucks</a>).
        </p>
        <p>
          Others like YAML and TOML prioritize being easily human-readable.
          These data formats are incredibly useful for contexts in which the
          data is primarily being written by a human and passed to a program.
          These formats are aesthetically lightweight enough to feel natural
          writing, but can be difficult to work with as the data being encoded
          becomes more and more complex. Most of this stems from the fact that
          YAML is a much more complex encoding then you may at first realize
          (see:
          <a
            href="https://ruudvanasseldonk.com/2023/01/11/the-yaml-document-from-hell"
            >the YAML document from hell</a
          >).
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image15.png"
            alt="depiction of the same type of data structure represented in XML, JSON, and YAML"
          />
        </p>
        <p>
          Other formats like protobufs and flatpack serialize data structures
          directly into a binary format. This makes it nearly impossible for a
          person to parse these formats just by looking at them. But what they
          lack in readability, they make up for with efficiency. Information
          encoded in binary can be much denser than the same information encoded
          using strings. Delimiters and separators in binary formats can be a
          couple of bits rather than entire characters. By disregarding an
          emphasis on human readability, these formats can also be designed to
          be parsed or encoded much quicker than a format like JSON or XML.
        </p>
        <p>
          These binary formats really shine in contexts where performance is
          important. It is not uncommon to see these formats used in
          interactions between high throughput micro services or between
          processes running on the same machine that communicate heavily.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image16.png"
            alt="depiction of the same type of data structure represented in XML, JSON, and YAML"
          />
        </p>
        <p>
          Opinions can get pretty heated about the pros and cons of each of
          these formats. Searching "Everything wrong with
          $data_serialization_format" will yield a number of blog posts and
          Hacker News comments lamenting each of these formats.
        </p>
        <p>
          These data interchange formats show up everywhere. You see them in
          database rows, you see them as payloads in apis, you see them as
          formats for config files, and you see them as ways to communicate
          between different programs. These formats are really what make so many
          string and binary interfaces between programs usable for complex
          tasks.
        </p>
        <h3>Seeing parsers and encoders in real programs</h3>

        <p>
          If you squint hard enough at most programs, you can eventually find a
          parser or encoder somewhere in its functionality. As we mentioned in
          an earlier section, most programs have a parser or encoder somewhere
          at the edges of their functionality.
        </p>
        <p>
          For example, consider programs like Word, Keynote, or Photoshop. All
          of these programs allow users to create, update, and share digital
          projects of some form or another. At first, it may seem like parsers
          and encoders have nothing to do with these programs. But it turns out,
          they are relevant in a number of ways.
        </p>
        <p>
          One of the more obvious ways these programs rely on parsers and
          encoders is in the file formats they use for saving projects. Each of
          these programs has a file type that can be used to save and share the
          application’s project state.
        </p>
        <ul>
          <li>.docx for Word</li>

          <li>.key for keynote presentations</li>

          <li>.psd for photoshop projects</li>
        </ul>
        <p>
          These files are encodings of the structured data needed to open a
          project that was previously loaded in one of these applications. These
          file formats allow a program to store the state necessary for the
          application to close and reopen while keeping all of the project data
          exactly where you left off. The file formats can be binary or textual
          representation of that structured data.
        </p>
        <p>
          This all should be starting to sound familiar. These programs are
          taking <strong>structured project data</strong> and encoding it into
          <strong>a string or binary format</strong>. Parsers and encoders are
          the key that allows these programs to save project files.
        </p>
        <p>
          I’ll illustrate the point in some more detail for a photoshop .psd
          project file. For some photoshop project, we are going to have a big
          set of structured data that the application needs for our project, it
          will include the images, the layers, and the effects that compose the
          project. When we write that data out to a .psd file, we are going to
          use a .psd specific encoder, and when we read that data back, we are
          going to use a .psd parser.
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image17.png"
            alt="depiction of the same type of data structure represented in XML, JSON, and YAML"
          />
        </p>
        <p>Now let’s consider another example.</p>
        <p>
          Many programs that software engineers work with on a day in and day
          out basis are run from the command line. Programs like git, curl and
          vim can all be run from the command line. Where can we find the
          parsers and encoders in these programs?
        </p>
        <p>
          Again, at least one example can be found at the edges of their
          functionality. Each of these programs has a set of possible input
          parameters and configurations. We can invoke each of the programs with
          specific options like -l or -h, or we can pass arguments values as
          arguments with fields like -m “my message”.
        </p>
        <p>
          All of these arguments and options are passed as one long string of
          words to the running program, it is up to the program to determine
          what options were set, how arguments are passed to those options and
          so on.
        </p>
        <p>
          In this case, it is us programmers who are encoding our intention for
          the program into a string, and it is the program who is parsing that
          structured intention. Even though there are a set of conventions for
          the structure of command line interfaces, each program can implement
          its interface however it pleases. Each program can build its own
          unique argument parser if the author pleases.
        </p>
        <p>
          We’ve only covered two examples of how parsers and encoders show up in
          real world software, but hopefully by now, anyone reading along should
          know how to identify parsers and encoders in the software they are
          using.
        </p>
        <p>
          A parser and encoder should be plainly visible when we consider a
          browser is using transforming html into a DOM or a database writing
          structured records to a file on disk.
        </p>
        <p>
          Pretty much any time two programs are communicating… you are going to
          find a parser or encoder!
        </p>
        <h2 id="4-takeaways">4: Takeaways</h2>

        <p>
          There are many useful takeaways in this post about parsers and
          encoders. You could note that parsers and encoders are fundamental to
          enable communication between programs. You could take away the idea
          that programs need contracts for the formats they will use to
          communicate with each other. You could take away that parsers are
          pretty neat.
        </p>
        <p>
          For me though, the most important takeaway I gleaned from this
          experience is that you don’t need to know every last detail about how
          a software component is implemented in order to have profound insights
          about how that component is used.
        </p>
        <p>
          Even with my incomplete and flawed understanding of how parsers are
          implemented, I still came to appreciate that parsers are used in
          almost every program. Despite my failed attempts to “learn parsers” I
          was still able to have a realization so big that it changed how I see
          almost every program I use.
        </p>
        <p>
          This may seem like an obvious takeaway, of course we don’t need to
          know how every program is constructed, and of course you can have
          profound realizations about software without knowing the intimate
          details of how it is built.
        </p>
        <p>
          But, I find that while learning about software and programming, it is
          easy to put all of your attention into the nuance of some particular
          program. It is easy to spend days, weeks or months trying to wrap your
          head around how a program works. Your entire field of vision can
          easily zero in onto one specific aspect of the program you are working
          on. When I find myself in those situations, I am finding it useful to
          remind myself to take a step back and think about how the software is
          used rather than how it is built.
        </p>
        <p>
          So, with all of that said, thanks parsers, I still don’t really get
          how you work, but I appreciate the lessons 💛
        </p>
        <p>
          <img
            src="/assets/blog/parsers-and-encoders-everywhere/images/image18.png"
            alt="depiction of the same type of data structure represented in XML, JSON, and YAML"
          />
        </p>
      </article>
    </main>
  </body>
</html>
