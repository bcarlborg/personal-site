<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/global-styles.css">
        <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-woo-guy-32-32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon-woo-guy-96-96.png">
        <link rel="icon" type="image/png" sizes="180x180" href="/assets/favicon-woo-guy-180-180.png">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="og:title" content="A Snake-like Game in RISC-V Assembly">
        <meta name="og:description" content="Beau Carlborg's Website">
        <title>A Snake-like Game in RISC-V Assembly</title>
    </head>
    <body>
        <header>
            <a href="/index.html">‚èé back home</a>
        </header>
        <main>
            <article>
                <h1 id="article-title">A Snake-like Game in RISC-V Assembly</h1>
                <div id="article-contents">
                    <i id="article-metadata">Originally Authored: 2024 May | Last Updated: 2024 May | Reading time: ~5 min | Author: Beau Carlborg</i>

                    <br>
                    <br>
                    <strong>Article Contents:</strong>
                    <br>

                    <a href="#the-project" }>
                        The Project
                    </a>
                    <br>
                    <a href="#why-do-this-project" }>
                        Why do this project?
                    </a>
                    <br>
                    <a href="#what-i-learned" }>
                        What I learned
                    </a>
                    <br>
                    <a href="#in-conclusion" }>
                        In Conclusion
                    </a>
                </div>
                <p><em>The code for this project can be found <a href="https://github.com/bcarlborg/snake-game-in-riscv-assembly">üëâhereüëà</a>.</em></p>
                <h2 id="the-project">The Project</h2>
                <p>I built a version of the classic snake game in RISC-V assembly! This is a project I have been chipping away at since the beginning of the year, and now that it is wrapped up, I am super excited to share it!</p>
                <p>This is a very bare bones implementation of snake. The game begins as soon as the program starts, and the program halts when your snake dies. The snake changes direction when the W A S D keys are pressed and the snake dies when it collides with itself or with a wall. Food appears at random locations across the map, and your score increases one point at a time as your snake consumes food.</p>
                <p>The project runs on qemu&#39;s emulated RISC-V <a href="https://www.qemu.org/docs/master/system/riscv/virt.html">virt computer platform</a>. The game is written at an embedded level. This means that there is no operating system running to support the program. The game software is responsible for knowing the system&#39;s memory map, communicating directly with devices, managing interrupts, and more!</p>
                <p>(Some people might reasonably take issue with this definition of &quot;embedded&quot; considering that the virt platform is a system that can only be run in an emulated environment... but these are just the terms we are going to roll with.)</p>
                <p><img src="/assets/blog/a-snake-like-game-in-risc-v-assembly/snake-final-demo.gif" alt="snake like game demo"></p>
                <h2 id="why-do-this-project">Why do this project?</h2>
                <p>There were two reasons I was interested in starting this project.</p>
                <p>Firstly, I wanted to become more familiar with a modern assembly language. Before this project, the only assembly language I had worked with in earnest was a much older 8-bit assembly language for the 6502 CPU. While I learned from working with that language, I felt that I could benefit from seeing what assembly languages being designed today look and feel like.</p>
                <p>After a few false starts with other architectures like x86 and arm, I decided to implement my game in RISC-V assembly. I chose RISC-V because the entire RISC-V platform is very well documented and because there are an abundance of educational materials available for the architecture.</p>
                <p>The second reason that I was interested in this project is that I wanted to get familiar with writing software that interacts directly with a computer system. Usually, in software development, we rely on the operating system to manage and abstract away the hardware that our code is running on. I wanted to peel away some of those layers and learn how to create a program that can directly utilize the underlying system. I was curious about what the interface do devices on the computer system is. I wanted to learn how a program interacts with those devices over the course of a full program&#39;s execution.</p>
                <p>Running my program on the emulated RISC-V virt platform in Qemu was the perfect way to get some initial exposure to programming directly for a computer system. The virt platform is a computer platform that is meant to be emulated -- there are no real physical risc-v virt computer systems. Without going into too much detail about what the virt computer system is, it is suffice to say that it is similar to programming a true physical computer system but with dramatically simpler devices that make the system easier to emulate and program for.</p>
                <h2 id="what-i-learned">What I learned</h2>
                <p>This project was a great way to dip my toes into this lower level of software development and I learned a lot while making it. I&#39;ll list some of the learnings that have stuck with me most from the project:</p>
                <p><em>Starting with a &quot;blank canvas&quot; was very difficult.</em></p>
                <p>I wanted to understand how the computer system worked from the ground up. So I didn&#39;t want to start with some sort of template or starter code. I wanted to understand how to appropriately configure and start up qemu to run my program. I wanted to learn how each device worked and what each device&#39;s startup sequence was. I wanted to really write my program from the ground up.</p>
                <p>And so, I wrote all of the software for this program myself. Sure, I used many other reference programs to guide my development, but I tried to never write new functionality unless I could explain how it worked.</p>
                <p>Taking this approach for the project, meant that I really got to deeply learn the system... But it also meant that I spent a long time toiling away getting everything setup while seeing very very little progress in my project. But once I had learned how to organize my project, how to configure qemu, and how to utilize all of the devices I needed the application logic for the game itself came together quite quickly!</p>
                <p><em>Assembly language is repetitive.</em></p>
                <p>This almost goes without saying but, assembly language is very verbose. Oftentimes, the most frustrating part of writing it is simply how many lines of code you need to repeat to get anything done.</p>
                <p>Were I to do a similar project in RISC-V assembly again, I would spend some time investing in macros and snippets to make the process of writing code a bit less repetitive.</p>
                <p><em>I wish I had invested in better error reporting.</em></p>
                <p>Bugs in my program would usually show up as the game simply hanging. Often times, it took quite a bit of time to find the bug. Sometimes, the issue it was invalid assembly (loading or storing from an invalid address or some such mistake) and other times, the issue was invalid game logic causing an infinite loop.</p>
                <p>The RISC-V platform I was using could support relatively useful error reporting. When an invalid instruction was run, an exception could be raised and your program would be interrupted with a code indicating the type of invalid instruction that caused the exception. I never made good use of this facility.</p>
                <p>I wish I had taken the time to build our a simple error reporting procedure to run when the system panicked. Having that starting point for debugging would have been incredibly useful.</p>
                <p><em>You can do a lot without dynamic memory allocations.</em></p>
                <p>My snake program does not use any dynamic memory allocation! Most of the logic for the program is written in temporary registers and stack variables. A small amount of game state has statically allocated sections of data. But I never needed to build out a dynamic memory allocation system.</p>
                <p><em>Bootloaders are witchcraft.</em></p>
                <p>One benefit of running my program using an emulated computer system with Qemu was that my program would simply be loaded directly into the system ram when qemu started. On a real physical system, my program would need to be saved on some form of persistent storage like flash and a bootloader program would be responsible for initializing the ram on your system and brining your program from flash into memory.</p>
                <p>I really wanted to learn more about bootloaders, but ultimately decided that setting up or building a bootloader was beyond the scope of the project. Bootloaders seem like a fascinating rabbit hole that I will like like fall into sometime later.</p>
                <p><em>Devices and Interrupts are not that scary.</em></p>
                <p>The two aspects of writing a program at this level that intimated me most were devices and interrupts. There are parallels for each of these concepts at higher levels of the stack, but I was mostly very unsure how my program would use these two interfaces. The process of setting up my first device and configuring my first interrupt was very difficult, but once I had those, the rest followed easily.</p>
                <p>When it comes down to it, devices are not so different from &quot;magic global variables&quot; that you see in some software. Each devices is represented to your program as a list of memory addresses. By writing specific values to those addresses, your device will do different things. The hard part is figuring out what values cause which behaviors.</p>
                <p>Similarly, once they were set up completely Interrupts are not so different than event handlers in higher level languages. You effectively tell the system that when an interrupt occurs, program execution should jump to a specific function and start executing there. Once that function returns, your program will resume where it left off. This is somewhat of an understatement... but not by much.</p>
                <p><em>Assembly is not the lowest level of abstraction and your cpu is not what it looks like.</em></p>
                <p>While working on this project, I was surprised how many times I touched upon very complex abstractions/implementations that the CPU creates for software executing on the machine. Wether it was out of order execution order or CPU caches for memory, I don&#39;t know enough about CPU design to describe the kinds of abstractions that I was bumping up against well, but I know they are there now.</p>
                <p>Before this project, I felt like programming in assembly was about as low of level abstraction as a programmer could reasonably learn. Now though, I feel even more mystified by the kinds of optimizations that a CPU provides to the software running on the system.</p>
                <h2 id="in-conclusion">In Conclusion</h2>
                <p>This was a fantastic project! I spent many months getting everything working, but ultimately I learned a lot. This project gave me that special kind of confidence that you feel when you learn how to write software a new lower level of abstraction than you previously could. There is something empowering about knowing that even at the lowest levels of the software stack, there is no magic.</p>
            </article>
        </main>
    </body>
</html>