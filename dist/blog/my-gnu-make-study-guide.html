<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" type="text/css" href="/global-styles.css?v=ed52966d34073049c08f3c0cf5c5d54d88b751dd9773da7450df59cbc57d77ed">
        <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32-32.png?v=2">
        <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon-96-96.png?v=2">
        <link rel="icon" type="image/png" sizes="180x180" href="/assets/favicon-180-180.png?v=2">
        <link rel="apple-touch-icon" href="/assets/favicon-180-180.png?v=2">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="og:title" content="My GNU Make Study Guide">
        <meta name="og:description" content="Beau Carlborg's Website">
        <title>My GNU Make Study Guide</title>
    </head>
    <body>
        <header>
            <a href="/index.html">⏎ back home</a>
        </header>
        <main>
            <article>
                <h1 id="article-title">My GNU Make Study Guide</h1>
                <div id="article-contents">
                    <i id="article-metadata">Published: November 20, 2024</i>

                    <br>
                    <br>
                    <strong>Article Contents:</strong>
                    <br>

                    <div class="h2-toc-item">
                        <a href="#make-as-a-build-system" }>
                            Make as a Build System
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#make-is-a-build-automation-system-aka-a-build-system" }>
                            🏭 Make is a Build Automation System (a.k.a. a Build System).
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#️build-systems-use-dependency-graphs-to-build-your-project" }>
                            🕰️ Build Systems use Dependency Graphs to Build Your Project
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#️dependency-graphs-are-encoded-in-rules-of-makefiles" }>
                            🧑‍⚖️ Dependency Graphs are Encoded in Rules of Makefiles
                        </a>
                    </div>

                    <div class="h2-toc-item">
                        <a href="#simple-make-syntax" }>
                            Simple Make Syntax
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#simple-rules" }>
                            📜 Simple Rules
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#️simple-variable-assignment" }>
                            ✏️ Simple Variable Assignment
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#basic-automatic-variables" }>
                            🤖 Basic Automatic Variables
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#basic-function-invocation" }>
                            🎰 Basic Function Invocation
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#common-functions" }>
                            💹 Common Functions
                        </a>
                    </div>

                    <div class="h2-toc-item">
                        <a href="#syntax-for-more-general-rules" }>
                            Syntax for More General Rules
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#phony-targets" }>
                            🤡 Phony Targets
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#wildcard-rules" }>
                            🎨 Wildcard Rules
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#️pattern-rules" }>
                            🏵️ Pattern Rules
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#-built-in-rules" }>
                            🫥 Built-in Rules
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#multiple-targets-per-rule" }>
                            👬 Multiple Targets per Rule
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#order-only-prerequisites" }>
                            🦏 Order-only Prerequisites
                        </a>
                    </div>

                    <div class="h2-toc-item">
                        <a href="#other-useful-syntax" }>
                            Other Useful Syntax
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#-variable-substitution-references" }>
                            🧞 Variable Substitution References
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#make-syntax-for-recipes" }>
                            👨‍🍳 Make Syntax for Recipes
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#️different-types-of-variable-assignment" }>
                            🧟‍♂️ Different Types of Variable Assignment
                        </a>
                    </div>

                    <div class="h2-toc-item">
                        <a href="#other-bits-and-bops" }>
                            Other Bits and Bops
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#make-executes-each-recipe-line-in-its-own-subshell" }>
                            🛶 Make Executes Each Recipe Line in its Own Subshell
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#️creating-a-prerequisite-that-is-always-out-of-date" }>
                            🏚️ Creating a Prerequisite That Is Always Out of Date
                        </a>
                    </div>

                    <div class="h3-toc-item">
                        <a href="#using-multiple-makefiles" }>
                            👩‍👩‍👧‍👦 Using Multiple Makefiles
                        </a>
                    </div>
                </div>
                <p>I have a love-hate relationship with <code>make</code>.</p>
                <p>On one hand, it is one of my favorite tools. It is installed almost everywhere. For simple projects it is easy to setup, and when configured well, it is easy to run and extend. On the other hand, writing makefiles for anything other than trivial builds can be tough. The language and syntax of makefiles has many sharp edges buried in the details. Every time I want to write a non-trivial makefile, I have to reacquaint myself with a grab bag of make specific stuff to get going again.</p>
                <p>I created this <em>study guide</em> in an attempt to really solidify my understanding of the core features you can use in makefiles. To make this study guide, I did two things:</p>
                <ol>
                    <li>I read a few papers that generally describe build systems. I then tried to describe <code>make</code> framed in the terms of those papers. That is what is covered in the <a href="#make-as-a-build-system">Make as a Build System</a> section.</li>
                    <li>I read through almost every section of the official <a href="https://www.gnu.org/software/make/manual/make.html">make documentation</a> and tried to note down the features of the tool and the language that&#39;d I&#39;d come across or used before. I then tried to explain each of those features in my own words in a section of this document.</li>
                </ol>
                <p>Disclaimer: This post is more of a collection of notes than a cohesive piece of writing. I have not taken the time to massage this into writing that flows, and frankly, this is neither the topic nor the post that I want to make that investment in. I am publishing this in spite of its rough condition because it might still have some value for others and because not everything needs to be perfect 💎</p>
                <h2 id="make-as-a-build-system">Make as a Build System</h2>
                <h3 id="make-is-a-build-automation-system-aka-a-build-system">🏭 Make is a Build Automation System (a.k.a. a Build System).</h3>
                <ul>
                    <li>To get oriented with make, it is useful to nail down some terms that we&#39;ll use to talk about this kind of software.<ul>
                            <li>build system: a program or set of programs that automate your build process.</li>
                            <li>build process: the sequence of all build tasks required to generate the correct output artifacts from your input source files.</li>
                            <li>build task: the smallest unit of work in your build process; these tasks cannot be broken down into smaller tasks. Build tasks may call one or many build tools.</li>
                            <li>build tools: programs that accept source files as input and generate output files or initiate some side effect based on your input source files.</li>
                            <li>A build: is a single execution of your build process.</li>
                        </ul>
                    </li>
                    <li>Some examples of these terms in action:<ul>
                            <li>In a C project where you have many source files that are used to create a single executable.<ul>
                                    <li>Your <em>build process</em> is all of the steps you need to take to compile the source files and link object files into an executable. If you have test suite, your build process would also include the steps you need to build those tests.</li>
                                    <li>This project would have many <em>build tasks</em> like compiling each <code>.c</code> file to <code>.o</code> file and linking the <code>.o</code> files together into an executable.</li>
                                    <li>This project would also have <em>build tools</em> like a compiler and linker.</li>
                                    <li>A <em>build</em> of this project would be the creation of the output executable from all the source files using the compiler and the linker.</li>
                                </ul>
                            </li>
                            <li>In a React project where you are writing JSX code that will be converted into vanilla js to be run on the browser<ul>
                                    <li>Your <em>build process</em> would be all the steps you need to take to convert your source <code>jsx</code> files into a set of vanilla javascript files that can be hosted on a webserver.</li>
                                    <li>Your <em>build tasks</em> include running your <code>jsx</code> files through a transpiler like <code>babel</code> to create vanilla js and likely a step of running those files through a bundler like <code>webpack</code> to turn them into a neat minified js file that can be served to clients.</li>
                                    <li>Your <em>build tools</em> would be those executables like <code>webpack</code> and <code>babel</code>.</li>
                                    <li>A <em>build</em> of your project would be the creation of the assets that will be hosted on your webserver.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>References:<ul>
                            <li><a href="https://arxiv.org/abs/1203.2704">A Model and Framework for Reliable Build Systems</a>: Provides a thorough model that allows us to define what a build system is and how one works. The terms and definitions I use to describe build systems and their component parts come from this paper.</li>
                        </ul>
                    </li>
                </ul>
                <h3 id="️build-systems-use-dependency-graphs-to-build-your-project">🕰️ Build Systems use Dependency Graphs to Build Your Project</h3>
                <ul>
                    <li>What is it that separates the bone fide build systems from a plain old scripts? If the purpose of a build system is to automate the build process of a project... we could just automate with a simple shell script right?<ul>
                            <li>Yes, you definitely could! And that would be a build system in its own right, but most build system programs are able to plan and execute a build of your project faster than a naive script by using information about the structure of your project.</li>
                        </ul>
                    </li>
                    <li>Many build system programs create an internal representation of your project&#39;s build dependency graph and use it to execute builds in an efficient way.<ul>
                            <li>The build dependency graph is a directed acyclic graph (D.A.G.) that specifies the inputs and outputs of each build task in your project (see the image below).</li>
                            <li>The build system can then use that graph to figure out the correct sequence of build tasks needed to create some artifact.</li>
                        </ul>
                    </li>
                </ul>
                <p><img src="/assets/blog/my-gnu-make-study-guide/dependency-graph.png" alt="dependency graph example"></p>
                <ul>
                    <li>Build systems have different mechanisms for deriving your project&#39;s build dependency graph.<ul>
                            <li>Some build systems, like make, require the programmer to elaborate and specify the project&#39;s build dependency graph.</li>
                            <li>Others automatically derive the build dependency graph of your project based on the contents of your source files.</li>
                        </ul>
                    </li>
                    <li>Build systems use this dependency graph to implement two features that can make your builds run faster: <em>Incremental Builds</em> and <em>Parallel Builds</em>.<ul>
                            <li>In an incremental build, results from previous builds are used in the current build.<ul>
                                    <li>Effectively, intermediate build results are cached for use in future builds.</li>
                                    <li>The build system you use is responsible for figuring out which cached build artifacts are stale and need to be reconstructed for the current build.</li>
                                    <li>Make is an incremental build system by default.</li>
                                </ul>
                            </li>
                            <li>In a parallel build, multiple build tasks of the build process are run at the same time.<ul>
                                    <li>Builds typically involve many steps, many of which are independent from each other and can be run concurrently.</li>
                                    <li>The build system you use is responsible for identifying which build tasks are appropriate to run in parallel.</li>
                                    <li>Make can be configured to run build tasks in parallel.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>References:<ul>
                            <li><a href="https://arxiv.org/abs/1203.2704">A Model and Framework for Reliable Build Systems</a>: Provides a specific model of how build systems use dependency graphs and how build systems evaluate whether or not nodes in that graph are out of date.</li>
                            <li><a href="https://arxiv.org/abs/2202.05328">Forward Build Systems, Formally</a>: Describes a build system that can derive a project&#39;s build dependency graph from the source of the project.</li>
                        </ul>
                    </li>
                </ul>
                <h3 id="️dependency-graphs-are-encoded-in-rules-of-makefiles">🧑‍⚖️ Dependency Graphs are Encoded in Rules of Makefiles</h3>
                <ul>
                    <li>Make requires that a user specify the dependency graph for their project in a <code>Makefile</code></li>
                    <li>The programmer configuring the build system writes a <code>Makefile</code> that stores a sequence rules.</li>
                    <li>Each of these rules encodes one of the dependencies in your build process.</li>
                    <li>Makefiles are an example of declarative code; they specify all of the dependencies in your project and how to build each dependency rather than specifying how to execute the build step by step (like you would in an imperative language).</li>
                    <li>Each rule has a target, zero or many prerequisites, and a recipe.<ul>
                            <li>The target can target is file that the rule creates when it is run.</li>
                            <li>The prerequisites are the files that the target depends on.</li>
                            <li>The recipe is the set of instructions for creating the target.</li>
                        </ul>
                    </li>
                    <li>The syntax for a rule is as follows:</li>
                </ul>
                <pre><code>target: prerequisite1 prerequisite2 ...
  recipe-line-1
  recipe-line-2
  ...
</code></pre>
                <ul>
                    <li>Simple rules describe a single node in the build dependency graph. More general rules can be written to describe many different parts of the dependency graph.</li>
                    <li>Makefiles also support a number of other programming constructs like variables, functions, pattern matching, and shell globbing, but it is useful to remember that these constructs only exist to help you write better rules.</li>
                    <li>To run make, you specify the target (or targets) you would like make to build, and make will consult the rules in your <code>Makefile</code> to determine which recipes to run.</li>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Introduction">Chapter 2: An Introduction to Makefiles</a></li>
                        </ul>
                    </li>
                </ul>
                <h2 id="simple-make-syntax">Simple Make Syntax</h2>
                <h3 id="simple-rules">📜 Simple Rules</h3>
                <ul>
                    <li>Rules are really the core of of what makes make. The way make builds your project is entirely determined by the rules you write.</li>
                    <li>There are many ways to write complex rules, but rules follow the same basic syntax that is exemplified by simple rules.</li>
                    <li>A simple rule specifies a file to build as its target and has one or many files as prerequisites.</li>
                </ul>
                <pre><code>target: prerequisite1 prerequisite2 ...
  recipe-line-1
  recipe-line-2
  ...
</code></pre>
                <ul>
                    <li>Make determines that the target needs to be built by consulting the file system for information about the target and the prerequisites.<ul>
                            <li>If the target file does not exist, the target must be built.</li>
                            <li>If any of the prerequisites do not exist, the target must be built.</li>
                            <li>When the last update timestamp of any one of the prerequisites is newer than the last update timestamp of the target, the target must be rebuilt.</li>
                        </ul>
                    </li>
                    <li>The recipe for a rule is a sequence of shell script lines of code.<ul>
                            <li>If the target is a file in the file system, then those shell script lines should create the target file using the prerequisite files.</li>
                        </ul>
                    </li>
                    <li>An example of a few simple rules that compile C files and link the outputs to make an executable.</li>
                </ul>
                <pre><code>main: main.o helper.o
  ld -o main main.o helper.o

main.o: main.c helper.h
  gcc -c -o main.o main.c

helper.o: helper.c
  gcc -c -o helper.o helper.c
</code></pre>
                <ul>
                    <li>Example running <code>make</code> against file</li>
                </ul>
                <pre><code># Print out the directory contents before running make
&gt; tree ./
./
├── Makefile
├── helper.c
├── helper.h
└── main.c

# Build main target
&gt; make main
gcc -c -o main.o main.c
gcc -c -o helper.o helper.c
ld -o main main.o helper.o

# Try to build the main target again, but nothing happens
# because everything is up to date
&gt; make main
make: `main&#39; is up to date.

# Print the directory content again so we can see the files
# make generated.
&gt; tree ./
./
├── Makefile
├── helper.c
├── helper.h
├── helper.o
├── main
├── main.c
└── main.o
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Introduction">Chapter 2: An Introduction to Makefiles</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="️simple-variable-assignment">✏️ Simple Variable Assignment</h3>
                <ul>
                    <li>Make supports an entire little programming language, and what would a programming language be without variables.</li>
                    <li>The basic syntax for variable assignments in make is as follows:</li>
                </ul>
                <pre><code>variable_name=variable_value

# Whitespace before and after &#39;=&#39; is ignored, so this is equivalent
variable_name = variable_value

# As is this
variable_name        =        variable_value
</code></pre>
                <ul>
                    <li>Variable names can be any sequence of characters not containing the following characters: <code>:</code>, <code>#</code>, <code>=</code>, or whitespace.<ul>
                            <li>However, variable names with upper and lower case letters, numbers, and underscores are recommended.</li>
                        </ul>
                    </li>
                    <li>All variables in make have values that are strings. There are no other datatypes for variables.<ul>
                            <li>The beginning of the string value starts after the <code>=</code> character and any whitespace that follows it.</li>
                        </ul>
                    </li>
                    <li>Some variable assignment examples:</li>
                </ul>
                <pre><code># `name` gets the string value &quot;beau carlborg&quot;
name = beau carlborg

# `location` gets the value &quot;oakland&quot; (leading whitespace is ignored)
location =            oakland

# `occupation` gets the string value &quot;software    engineer&quot; (internal whitespace preserved)
occupation = software    engineer

# `age` gets string value &quot;42&quot; (notice it is a string, not a number)
age = 42

# Common practice is to not use spaces around the `=` in an assignment
CC=gcc
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Basics">Chapter 6.1: Basics of Variable Definitions</a></li>
                        </ul>
                    </li>
                </ul>
                <p><strong>📖 Basic Variable Reference:</strong></p>
                <ul>
                    <li>The variables you declare can be used in any part of a makefile. The definitions of other rules, targets, prerequisites, recipes, you name it.</li>
                    <li>The syntax for referencing a variable is as follows:</li>
                </ul>
                <pre><code>$(variable_name)

# or alternatively
${variable_name}

# Or, for single character variable names only
$v
</code></pre>
                <ul>
                    <li>⚠️ The single character variable reference is a common source of bugs for those new to writing <code>makefiles</code>.</li>
                </ul>
                <pre><code># This may look like a valid variable reference for the variable `foo`
$foo

# But, in fact, make treats this reference as if it were
$(f)oo
</code></pre>
                <ul>
                    <li>Variable names can be referenced in targets, prerequisites, or recipes.</li>
                </ul>
                <pre><code>TARGET_NAME=main
PREREQUISITE_NAMES=main.o helper.h helper.o
LINKER=ld

$(TARGET_NAME): $(PREREQUISITE_NAMES)
  $(LINKER) -o $(TARGET_NAME) $(PREREQUISITE_NAMES)
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Using-Variables">Chapter 6: How to Use Variables</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="basic-automatic-variables">🤖 Basic Automatic Variables</h3>
                <ul>
                    <li>All of our rules have been static so far, meaning that the target file and all of the prerequisite files are explicitly listed.<ul>
                            <li>Later on, we will introduce syntax that allows for rules where the targets and prerequisites are determined when <code>make</code> is run.</li>
                            <li>For those kinds of rules, we need a mechanism to reference the target and prerequisite names that make derived for us in our recipes.</li>
                            <li>Make provides automatic variables to help with this.</li>
                        </ul>
                    </li>
                    <li>Within every recipe, make assigns the following <em>Automatic Variables</em> for you based on the targets and prerequisites in your rule. These variable references will likely have different values in every rule&#39;s recipe.<ul>
                            <li><code>$@</code>: the name of the target file that caused the rule to be run.</li>
                            <li><code>$^</code>: the names of all prerequisites (separated by a space—even if they were separated by other whitespace in the rule declaration).</li>
                            <li><code>$&lt;</code>: the name of the first prerequisite.</li>
                            <li><code>$?</code>: the names of all prerequisites that are newer than the target.</li>
                            <li>And more! But these are the basics and the ones you see most commonly.</li>
                        </ul>
                    </li>
                    <li>Examples:</li>
                </ul>
                <pre><code>main: main.o helper.o
  ld -o $@ $^

main.o: main.c helper.h
  gcc -c -o $@ $&lt;

helper.o: helper.c
  gcc -c -o $@ $^
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Automatic-Variables">Chapter 10.5: Automatic Variables</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="basic-function-invocation">🎰 Basic Function Invocation</h3>
                <ul>
                    <li>Make provides a set of functions that can modify text values. Functions can be invoked anywhere that a variable can be referenced.</li>
                    <li>The basic function invocation syntax is as follows:</li>
                </ul>
                <pre><code>$(function_name argument1,argument2,argument3)

${function_name argument1,argument2,argument3}
</code></pre>
                <ul>
                    <li>In a function call, the function name and the arguments are separated by one or many whitespace characters and the function arguments are separated by commas.<ul>
                            <li>⚠️ This syntax makes passing (1) leading whitespace in your first argument (2) a comma in any of your arguments (3) an unmatched parenthesis in your arguments rather difficult.</li>
                            <li>The make documentation gives two basic solutions to this problem, but they are far from pretty.</li>
                        </ul>
                    </li>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Call-Function">Chapter 8.1: Function Call Syntax</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="common-functions">💹 Common Functions</h3>
                <ul>
                    <li>Some of the more common and generally illustrative basic functions</li>
                    <li><code>$(wildcard pattern)</code>: The <code>wildcard</code> function will match a pattern against your current working directory, and expand into a list of the files that match the wildcard pattern.<ul>
                            <li>Pattern will use <code>*</code>, <code>?</code>, and <code>[...]</code> characters for matching—just like the Bourne shell.</li>
                            <li>⚠️ <code>Wildcard</code> is matched against your working directory! Not the <code>Makefile</code>&#39;s directory. Most of the time, you are invoking <code>make</code> from the directory that the <code>Makefile</code> is in, but if not, you may not get the results you expect.</li>
                        </ul>
                    </li>
                </ul>
                <pre><code># If your current directory has these files
# ./
# ├── Makefile
# ├── test1.txt
# ├── test2.txt
# ├── test3.txt
# └── testA.txt

# `VAR1` would get value &quot;test1.txt test2.txt test3.txt testA.txt&quot;
VAR1=$(wildcard *.txt)

# `VAR2` would get value &quot;test1.txt test3.txt&quot;
VAR2=$(wildcard test[13].txt)

# `VAR3` would get value &quot;test1.txt test2.txt test3.txt testA.txt&quot;
VAR3=$(wildcard test?.txt)
</code></pre>
                <ul>
                    <li><code>$(shell shellscript_command)</code>: The <code>shell</code> function will perform command expansion of a shell command in the <code>Makefile</code>, meaning the function will evaluate to the text that executing the shell command sends to stdout.</li>
                </ul>
                <pre><code># `contents` will equal the data in the file `foo`
contents=$(shell cat foo)
</code></pre>
                <ul>
                    <li><code>$(subst from,to,text)</code>: Replaces every occurrence of the text in argument <code>from</code> with the text in argument <code>to</code> in the text in argument <code>text</code>.</li>
                </ul>
                <pre><code># `VAR1` would get value &quot;hola world&quot;
VAR1=$(subst hello,hola,hello world)

# `VAR2` would get value &quot;CompA.tsx CompB.tsx CompC.tsx&quot;
VAR2=$(subst .jsx,.tsx,CompA.jsx CompB.jsx CompC.jsx)
</code></pre>
                <ul>
                    <li><code>$(patsubst pattern,replacement,text)</code>: <code>patsubst</code> is very similar to <code>subst</code>, but it allows for including a <code>%</code> wildcard character in the <code>pattern</code> argument that can be used in the <code>replacement</code> argument.</li>
                </ul>
                <pre><code># `VAR1` would get value &quot;new_test1.txt new_test2.txt test3.pdf&quot;
VAR1=$(patsubst %.txt,new_%.txt,test1.txt test2.txt test3.pdf)
</code></pre>
                <ul>
                    <li><code>$(dir names…)</code>: Get the directory part of multiple paths.</li>
                </ul>
                <pre><code># `VAR1` would get value &quot;foo/ foo/bar/ ./&quot;
VAR1=$(dir foo/ foo/bar/baz.txt ./blamo)
</code></pre>
                <ul>
                    <li><code>$(notdir names…)</code>: Get the filename part of multiple paths.</li>
                </ul>
                <pre><code># `VAR1` would get value &quot;text baz.txt blamo&quot;
VAR1=$(notdir foo/text foo/bar/baz.txt blamo)
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation:<ul>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Text-Functions">8.3 Functions for String Substitution and Analysis</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Wildcard-Function">8.4 The <code>wildcard</code> Function</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Filename-Functions">8.5 Functions for File Names</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Shell-Function">8.7 The <code>shell</code> Function</a></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                <h2 id="syntax-for-more-general-rules">Syntax for More General Rules</h2>
                <h3 id="phony-targets">🤡 Phony Targets</h3>
                <ul>
                    <li>So far, in each of our rules, our target has been a file that the recipe of the rule creates. Sometimes it is useful to create a rule whose target does not correspond to any file.</li>
                    <li>When a target does not correspond to a file, we call it a phony target.</li>
                    <li>These can be useful in a number of situations:<ul>
                            <li>They allow you to run build tasks whose utility is that their recipe performs some useful side effect.</li>
                            <li>They allow you to create a rule which runs many other rules.</li>
                        </ul>
                    </li>
                    <li>Some examples of common phony targets:</li>
                </ul>
                <pre><code># `all` is a common phony target that typically has all of the major
# artifacts of a project as its dependencies
all: executable test-bench documentation

# `clean` is a common phony target whose recipe will remove all
# intermediate files created by other build rules
clean:
  rm -rf ./bin/*

# In previous projects that involved uploading binaries to external
# devices like FPGAs or EEPROMs, I&#39;ve used an `upload` phony target.
upload: executable
  loadFileToExternalDevice --device=fpga executable
</code></pre>
                <ul>
                    <li>⚠️ If a file is created in the same directory as the <code>Makefile</code> with a name of a phony target, it is possible for your phony targets to stop executing (because a file with that target name exists and is up to date).<ul>
                            <li>Make provides a directive that can be used to explicitly mark a target as phony, telling make not to consult the file system for a file with that name.</li>
                        </ul>
                    </li>
                </ul>
                <pre><code>.PHONY: clean
clean:
  rm -rf ./bin/*
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Phony-Targets">4.6 Phony Targets</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="wildcard-rules">🎨 Wildcard Rules</h3>
                <ul>
                    <li>Often times, you want to create a rule that applies to every target or prerequisite matching some pattern in a directory.</li>
                    <li>You can do this in make using wildcard characters in the target or prerequisite section of a rule.</li>
                </ul>
                <pre><code># Using a wildcard rule to make a list of prerequisites that includes
# each chapter text file in the current directory
book.txt: chapter*.txt
  cat $^ &gt; $@
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Wildcards">4.4 Using Wildcard Characters in File Names</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="️pattern-rules">🏵️ Pattern Rules</h3>
                <ul>
                    <li>Similar to wildcard rules, pattern rules allow you to write rules that are more general than basic rules.</li>
                    <li>Pattern rules allow you to create a rule for any target matching a particular pattern. That pattern can also be referenced in the prerequisite list of the rule.<ul>
                            <li>This connection between target and prerequisite using the pattern match is a powerful way to create dependencies that are named based on the target itself.</li>
                        </ul>
                    </li>
                    <li>Like with wildcard rules, automatic variables are essential so that you can reference the specific target and prerequisites for which the rule is being executed in the recipe.</li>
                </ul>
                <pre><code># This pattern rule tells make that the dependency for any file ending
# in `.o` is a file with the same base name ending in `.c`
%.o: %.c
  gcc -c -o $@ $^
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Pattern-Rules">10.5 Pattern Rules</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="-built-in-rules">🫥 Built-in Rules</h3>
                <ul>
                    <li>By default, make also references a number of built-in rules beyond those you define in your <code>Makefile</code> when you invoke it.</li>
                    <li>There are two built-in rules that you may still come across or shoot yourself in the foot with.</li>
                    <li>A rule for compiling <code>.o</code> files from <code>.c</code> files. According to the make documentation, &quot;<em>n</em>.o is made automatically from <em>n</em>.c with a recipe of the form <code>$(CC) $(CPPFLAGS) $(CFLAGS) -c</code>&quot;.</li>
                    <li>A rule for compiling executables from their corresponding <code>.o</code> files. According to the make documentation: &quot;<em>n</em> is made automatically from <em>n</em>.o by running the C compiler to link the program. The precise recipe used is <code>$(CC) $(LDFLAGS) _n_.o $(LOADLIBES) $(LDLIBS)</code>&quot;.</li>
                    <li>These default rules can be disabled by passing either the <code>-r</code> or <code>--no-builtin-rules</code> flag when <code>make</code> is invoked.</li>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Catalogue-of-Rules">10.2 Catalogue of Implicit Rules</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="multiple-targets-per-rule">👬 Multiple Targets per Rule</h3>
                <ul>
                    <li>In all of the rules up to this point, we have only had one target per rule. Make also has affordances for specifying multiple targets for a single rule.</li>
                    <li>There are two different variants of multiple target rules.</li>
                    <li>Independent multi-target rules are equivalent to writing the same rule once for each target.<ul>
                            <li>These are simply a nice syntax affordance for condensing multiple rules that have the same dependencies and recipe.</li>
                            <li>When the recipe is run, <code>$@</code> will be set to one of the targets.</li>
                        </ul>
                    </li>
                </ul>
                <pre><code>output1 output2 output3: prereq1 prereq2
  compile -o $@ $^

# The above rule is equivalent to these three rules
output1: prereq1 prereq2
  compile -o $@ $^

output2: prereq1 prereq2
  compile -o $@ $^

output3: prereq1 prereq2
  compile -o $@ $^
</code></pre>
                <ul>
                    <li>Rules with multiple targets can also be grouped target rules.<ul>
                            <li>The <code>&amp;:</code> separator between targets and prerequisites indicates that the targets should be treated as grouped targets.</li>
                            <li>These rules are useful when you have one rule that updates multiple targets at the same time.</li>
                            <li>If any one of the group targets is out of date, then the rule will be run again.</li>
                            <li><code>$@</code> will be set to the name of the particular target that triggered the rule to execute.</li>
                        </ul>
                    </li>
                </ul>
                <pre><code>foo bar biz &amp;: baz boz
  echo $^ &gt; foo
  echo $^ &gt; bar
  echo $^ &gt; biz
</code></pre>
                <h3 id="order-only-prerequisites">🦏 Order-only Prerequisites</h3>
                <ul>
                    <li>The default interpretation of prerequisites in rules is that make should run the recipe whenever any one of the prerequisites has an update timestamp that is newer than that of the target.</li>
                    <li>Order-only prerequisites allow you to specify prerequisites for a target that should only cause an execution of the recipe if the order-only prerequisite doesn&#39;t exist. Once the order-only prerequisite exists, any subsequent updates to it will not cause make to execute the rule again.</li>
                    <li>Order-only prerequisites are separated from normal prerequisites with a <code>|</code> character.</li>
                </ul>
                <pre><code># The `bin/` directory is an order-only prerequisite here. As long as it
# exists, no updates to it will cause the rule to re-run
executable: main.o | bin/
  ld -o executable main.o

main.o: main.c
  gcc -c -o main.o main.c

bin/:
  mkdir bin
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Order_002dOnly">4.3.2.2 Order-only Prerequisites</a></li>
                        </ul>
                    </li>
                </ul>
                <h2 id="other-useful-syntax">Other Useful Syntax</h2>
                <h3 id="-variable-substitution-references">🧞 Variable Substitution References</h3>
                <ul>
                    <li>Oftentimes in a makefile, you want to create one variable from another with a slight modification. You want to map over the values in one variable and generate your new one by performing some slight translation on the original variable.</li>
                    <li>Variable substitution references are a lightweight piece of syntax has some basic functionality for doing this.</li>
                    <li>The basic syntax of a variable subtitution reference allows you to replace the tail of every value in a variable with a new tail:</li>
                </ul>
                <pre><code>VAR_A:=foo.c bar.c baz.c

# VAR_B receives value foo.o bar.o baz.o
VAR_B:=$(A:.c=.o)
</code></pre>
                <ul>
                    <li>Substitution references also support the pattern syntax that you can use in a <code>patsubst</code> function call. This allows you to perform slightly more complex substitutions.</li>
                </ul>
                <pre><code>VAR_A:=foo.c bar.c baz.c

# VAR_B receives value foo_new.c bar_new.c baz_new.c
VAR_B:=$(A:%.c=%_new.c)

# This code using the patsubst function is equivalent
VAR_B:=$(patsubst %.c,%_new.c,$(VAR_A))
</code></pre>
                <p>references:</p>
                <ul>
                    <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/html_node/Substitution-Refs.html">6.3.1 Substitution References</a></li>
                </ul>
                <h3 id="make-syntax-for-recipes">👨‍🍳 Make Syntax for Recipes</h3>
                <ul>
                    <li>Make executes each line of code in the recipe in its own subshell. However, it does do some processing on the recipe lines first.</li>
                    <li>Breaking up recipe lines<ul>
                            <li>Lines in a recipe can get long; if you want to break the line up with a newline in the <code>Makefile</code>, but still have it executed by make as one shell line, a <code>\</code> character can be placed at the end of the line.</li>
                        </ul>
                    </li>
                    <li>Suppressing recipe echoing<ul>
                            <li>By default, when make executes a recipe, it echoes every line of shell it executes to the terminal. This behavior is called recipe echoing.</li>
                            <li>If a line in a recipe begins with the <code>@</code> character, then recipe echoing of that line will be suppressed.</li>
                        </ul>
                    </li>
                </ul>
                <pre><code># In this example, when the rule is run, the echo command will be
# executed, causing &quot;building the book!&quot; to be echoed, but make will
# not print `echo &quot;building the book!&quot;` to stdout
book.txt: chapter*.txt
  @echo &quot;building the book!&quot;
  cat $^ &gt; $@
</code></pre>
                <ul>
                    <li><strong>Ignoring errors in recipe lines</strong>
                        <ul>
                            <li>By default, make executes recipe lines one after another. If one of the recipe lines exits with a non-zero status code, then make will abort execution of the rest of the rule.</li>
                            <li>If you want to prevent aborting on errors for a particular shell line, prefix the line with <code>-</code>. This will tell make to continue to the next line of the recipe even if this line errors out.</li>
                        </ul>
                    </li>
                    <li><strong>Escaping <code>$</code> character in make recipes</strong>
                        <ul>
                            <li>By default, make will read any <code>$</code> character in a recipe as beginning a reference to a make variable.</li>
                            <li>If you want to escape the <code>$</code> character and have make pass it on to the shell command, you can add a second <code>$</code> character in front of the <code>$</code>.</li>
                        </ul>
                    </li>
                    <li>References:<ul>
                            <li>Make documentation:<ul>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Execution">5.1 Recipe Execution</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Recipe-Syntax">5.2 Recipe Syntax</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Errors">5.4 Errors in Recipes</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Splitting-Lines">5.5 Splitting Recipe Lines</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Echoing">5.7 Recipe Echoing</a></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
                <h3 id="️different-types-of-variable-assignment">🧟‍♂️ Different Types of Variable Assignment</h3>
                <ul>
                    <li>By default, variables in <code>makefiles</code> do not store the evaluated right-hand side value from the variable declaration. Instead, they store the right-hand side value as it was specified, and then evaluate that when the variable is referenced.</li>
                    <li>These variables are referred to as recursively expanded variables.</li>
                </ul>
                <pre><code>random=$(shell echo $$RANDOM)

all:
  @echo $(random)
  @echo $(random)

# Running `make all` against this `Makefile` will output two different
# random numbers because make executes the function from the declaration
# every time the variable is referenced.
</code></pre>
                <ul>
                    <li>The other type of variable assignment is known as simply expanded variables. These variables&#39; right-hand sides are evaluated at declaration time, and that evaluated value is stored in the variable.</li>
                </ul>
                <pre><code>random:=$(shell echo $$RANDOM)

all:
  @echo $(random)
  @echo $(random)

# Running `make all` against this `Makefile` will output the same number twice
# because make executes the function during the declaration and assigns the
# output to the variable.
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Flavors">6.2 The Two Flavors of Variables</a></li>
                        </ul>
                    </li>
                </ul>
                <h2 id="other-bits-and-bops">Other Bits and Bops</h2>
                <h3 id="make-executes-each-recipe-line-in-its-own-subshell">🛶 Make Executes Each Recipe Line in its Own Subshell</h3>
                <ul>
                    <li>When make executes a recipe, it executes each line of the recipe in its own subshell.</li>
                    <li>⚠️ This means that setting shell variables or changing directory in a <code>Makefile</code> recipe will not affect following lines.<ul>
                            <li>This can be confusing to new <code>Makefile</code> authors who expect the entire recipe is executed like a shell script.</li>
                        </ul>
                    </li>
                </ul>
                <pre><code>target1: prereq1
  cd subdir
  pwd          # pwd will not be subdir/ when pwd evaluates, because
               # the previous line was executed in a separate shell instance
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Execution">5.1 Recipe Execution</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="️creating-a-prerequisite-that-is-always-out-of-date">🏚️ Creating a Prerequisite That Is Always Out of Date</h3>
                <ul>
                    <li>Sometimes it is useful to have a prerequisite on a rule that is always out of date. This will ensure that the rule is always run even when the target is up to date.<ul>
                            <li>This can be useful when debugging to see what happens when a rule is run.</li>
                            <li>This can also be useful if you have a rule that updates a file every time the recipe is run</li>
                        </ul>
                    </li>
                    <li>This can be done by creating a dependency that is always out of date and adding it as a prerequisite on any rules you always want run.<ul>
                            <li>Another alternative is to mark your target file as <code>.PHONY</code>. But that is confusing because phony targets usually don’t have an associated file and it is not going to work if your target is a pattern target (you can’t mark a pattern as phony).</li>
                        </ul>
                    </li>
                </ul>
                <pre><code># The `FORCE` target has no dependencies and no rule,
# and thus can never be created and will always be out of date
FORCE:

# Every time make has `log.txt` as a goal or a prerequisite of another
# rule, it will consider `log.txt` out of date.
log.txt: FORCE
  echo &quot;MAKE BLAMO&quot; &gt; foobar.txt

# This is the same as the above, but using a pattern rule instead.

%.txt: FORCE
  echo &quot;MAKE BLAMO&quot; &gt; foobar.txt
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation — <a href="https://www.gnu.org/software/make/manual/make.html#Force-Targets">4.7.3 Force Targets</a></li>
                        </ul>
                    </li>
                </ul>
                <h3 id="using-multiple-makefiles">👩‍👩‍👧‍👦 Using Multiple Makefiles</h3>
                <ul>
                    <li>Once a project grows sufficiently large, having all of your build process logic included in one <code>Makefile</code> is too unwieldy.</li>
                    <li>Make has a few affordances for using multiple <code>makefiles</code> in a project, and include mechanism for importing the rules from one makefile and a mechanism for executing other makefiles.</li>
                    <li>Including <code>makefiles</code>:<ul>
                            <li>It is possible to include the rules from another <code>makefile</code> in your project by using the <code>include</code> directive.</li>
                            <li>Conceptually, you can imagine that calling the <code>include</code> directive expands all of the content of the included <code>makefiles</code> directly into your <code>Makefile</code> where the <code>include</code> directive is.</li>
                            <li>This can be useful if your project has shared variables that every <code>makefile</code> should use, or if your <code>makefile</code> includes a lot of boilerplate.</li>
                            <li>Some tools will process your source files and extract the appropriate make rules from them. The include mechanism allows you to incorporated those generated make rules into your build process dynamically.</li>
                            <li>The syntax for including other makefiles in your current makefile is as follows:</li>
                        </ul>
                    </li>
                </ul>
                <pre><code>include some_makefile.mk some_other_makefile.mk
</code></pre>
                <ul>
                    <li>
                        <p><strong>Recursively calling <code>makefiles</code></strong></p>
                        <ul>
                            <li>You can invoke <code>make</code> in a recipe in your current <code>makefile</code> by calling <code>$(MAKE)</code>.</li>
                            <li>Invoking this command is the same as calling <code>make</code> on the command line.</li>
                            <li>This is a useful pattern when you want to have makefiles in subdirectories of your project that are responsible for executing the build of those files.</li>
                            <li>Many projects have one simple <code>Makefile</code> at the top level of their project directory. This makefile is responsible for recursively executing make in those subdirectories.</li>
                            <li>That kind of setup might look like this:</li>
                        </ul>
                    </li>
                </ul>
                <pre><code>executable:
  cd src/ &amp;&amp; $(make)

tests:
  cd tests &amp;&amp; $(make)

docs:
  cd documentation &amp;&amp; $(make)
</code></pre>
                <ul>
                    <li>By default, when you invoke <code>make</code> recursively in this way, no information from your current <code>Makefile</code> is communicated to the recursively run <code>Makefile</code>.</li>
                    <li>It is possible to share variables from the calling <code>Makefile</code> to the recursive callee <code>Makefile</code> by using the <code>export</code> directive</li>
                </ul>
                <pre><code>my_exported_var:=foobar
export my_exported_var

subsystem:
  cd subdir &amp;&amp; $(MAKE)

# Now when `make` is executed in `subdir`, the variable `my_exported_var` will
# be defined during the execution of the `subdir` `Makefile`
</code></pre>
                <ul>
                    <li>References:<ul>
                            <li>Make documentation:<ul>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Include">3.4 Including Other Makefiles</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Recursion">5.7 Recursive Use of make</a></li>
                                    <li><a href="https://www.gnu.org/software/make/manual/make.html#Communicating-Variables">6.7 Communicating Variables to a Sub-make</a></li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </article>
        </main>
    </body>
</html>